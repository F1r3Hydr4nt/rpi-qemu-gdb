"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bsm = void 0;
/**
 * Bitcoin Signed Message
 * ======================
 *
 * "Bitcoin Signed Message" just refers to a standard way of signing and
 * verifying an arbitrary message. The standard way to do this involves using a
 * "Bitcoin Signed Message:\n" prefix, which this code does. You are probably
 * interested in the static Bsm.sign( ... ) and Bsm.verify( ... ) functions,
 * which deal with a base64 string representing the compressed format of a
 * signature.
 */
const address_1 = require("./address");
const bw_1 = require("./bw");
const cmp_1 = require("./cmp");
const ecdsa_1 = require("./ecdsa");
const hash_1 = require("./hash");
const key_pair_1 = require("./key-pair");
const sig_1 = require("./sig");
const struct_1 = require("./struct");
const workers_1 = require("./workers");
class Bsm extends struct_1.Struct {
    constructor(messageBuf, keyPair, sig, address, verified) {
        super({ messageBuf, keyPair, sig, address, verified });
    }
    static magicHash(messageBuf) {
        if (!Buffer.isBuffer(messageBuf)) {
            throw new Error('messageBuf must be a buffer');
        }
        const bw = new bw_1.Bw();
        bw.writeVarIntNum(Bsm.magicBytes.length);
        bw.write(Bsm.magicBytes);
        bw.writeVarIntNum(messageBuf.length);
        bw.write(messageBuf);
        const buf = bw.toBuffer();
        const hashBuf = hash_1.Hash.sha256Sha256(buf);
        return hashBuf;
    }
    static async asyncMagicHash(messageBuf) {
        const args = [messageBuf];
        const workersResult = await workers_1.Workers.asyncClassMethod(Bsm, 'magicHash', args);
        return workersResult.resbuf;
    }
    static sign(messageBuf, keyPair) {
        const m = new Bsm(messageBuf, keyPair);
        m.sign();
        const sigbuf = m.sig.toCompact();
        const sigstr = sigbuf.toString('base64');
        return sigstr;
    }
    static async asyncSign(messageBuf, keyPair) {
        const args = [messageBuf, keyPair];
        const workersResult = await workers_1.Workers.asyncClassMethod(Bsm, 'sign', args);
        const sigstr = JSON.parse(workersResult.resbuf.toString());
        return sigstr;
    }
    static verify(messageBuf, sigstr, address) {
        const sigbuf = Buffer.from(sigstr, 'base64');
        const message = new Bsm();
        message.messageBuf = messageBuf;
        message.sig = new sig_1.Sig().fromCompact(sigbuf);
        message.address = address;
        return message.verify().verified;
    }
    static async asyncVerify(messageBuf, sigstr, address) {
        const args = [messageBuf, sigstr, address];
        const workersResult = await workers_1.Workers.asyncClassMethod(Bsm, 'verify', args);
        const res = JSON.parse(workersResult.resbuf.toString());
        return res;
    }
    sign() {
        const hashBuf = Bsm.magicHash(this.messageBuf);
        const ecdsa = new ecdsa_1.Ecdsa().fromObject({
            hashBuf,
            keyPair: this.keyPair,
        });
        ecdsa.sign();
        ecdsa.calcrecovery();
        this.sig = ecdsa.sig;
        return this;
    }
    verify() {
        const hashBuf = Bsm.magicHash(this.messageBuf);
        const ecdsa = new ecdsa_1.Ecdsa();
        ecdsa.hashBuf = hashBuf;
        ecdsa.sig = this.sig;
        ecdsa.keyPair = new key_pair_1.KeyPair();
        ecdsa.keyPair.pubKey = ecdsa.sig2PubKey();
        if (!ecdsa.verify()) {
            this.verified = false;
            return this;
        }
        const address = new address_1.Address().fromPubKey(ecdsa.keyPair.pubKey);
        // TODO: what if livenet/testnet mismatch?
        if ((0, cmp_1.cmp)(address.hashBuf, this.address.hashBuf)) {
            this.verified = true;
        }
        else {
            this.verified = false;
        }
        return this;
    }
}
exports.Bsm = Bsm;
Bsm.magicBytes = Buffer.from('Bitcoin Signed Message:\n');
//# sourceMappingURL=bsm.js.map