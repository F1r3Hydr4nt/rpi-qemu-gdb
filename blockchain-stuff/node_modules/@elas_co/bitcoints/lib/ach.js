"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ach = void 0;
/**
 * Ach (Aes+Cbc+Hmac) (experimental)
 * =================================
 *
 * An "encrypt-then-MAC" that uses Aes, Cbc and SHA256 Hmac. This is suitable
 * for general encryption of data.
 *
 * The encrypted data takes the form:
 * (256 bit hmac)(128 bit iv)(128+ bits Aes+Cbc encrypted message)
 */
const aescbc_1 = require("./aescbc");
const cmp_1 = require("./cmp");
const hash_1 = require("./hash");
const random_1 = require("./random");
const workers_1 = require("./workers");
class Ach {
    static encrypt(messageBuf, cipherKeyBuf, ivBuf) {
        const encBuf = aescbc_1.Aescbc.encrypt(messageBuf, cipherKeyBuf, ivBuf);
        const hmacbuf = hash_1.Hash.sha256Hmac(encBuf, cipherKeyBuf);
        return Buffer.concat([hmacbuf, encBuf]);
    }
    static async asyncEncrypt(messageBuf, cipherKeyBuf, ivBuf) {
        if (!ivBuf) {
            ivBuf = random_1.Random.getRandomBuffer(128 / 8);
        }
        const args = [messageBuf, cipherKeyBuf, ivBuf];
        const workersResult = await workers_1.Workers.asyncClassMethod(Ach, 'encrypt', args);
        return workersResult.resbuf;
    }
    static decrypt(encBuf, cipherKeyBuf) {
        if (encBuf.length < (256 + 128 + 128) / 8) {
            throw new Error('The encrypted data must be at least 256+128+128 bits, which is the length of the Hmac plus the iv plus the smallest encrypted data size');
        }
        const hmacbuf = encBuf.slice(0, 256 / 8);
        encBuf = encBuf.slice(256 / 8, encBuf.length);
        const hmacbuf2 = hash_1.Hash.sha256Hmac(encBuf, cipherKeyBuf);
        if (!(0, cmp_1.cmp)(hmacbuf, hmacbuf2)) {
            throw new Error('Message authentication failed - Hmacs are not equivalent');
        }
        return aescbc_1.Aescbc.decrypt(encBuf, cipherKeyBuf);
    }
    static async asyncDecrypt(encBuf, cipherKeyBuf) {
        const args = [encBuf, cipherKeyBuf];
        const workersResult = await workers_1.Workers.asyncClassMethod(Ach, 'decrypt', args);
        return workersResult.resbuf;
    }
}
exports.Ach = Ach;
//# sourceMappingURL=ach.js.map