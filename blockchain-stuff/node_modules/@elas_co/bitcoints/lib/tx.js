"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tx = void 0;
/**
 * Transaction
 * ===========
 *
 * A bitcoin transaction.
 */
const bn_1 = require("./bn");
const br_1 = require("./br");
const bw_1 = require("./bw");
const ecdsa_1 = require("./ecdsa");
const hash_1 = require("./hash");
const hash_cache_1 = require("./hash-cache");
const script_1 = require("./script");
const sig_1 = require("./sig");
const struct_1 = require("./struct");
const tx_in_1 = require("./tx-in");
const tx_out_1 = require("./tx-out");
const var_int_1 = require("./var-int");
const workers_1 = require("./workers");
class Tx extends struct_1.Struct {
    constructor(versionBytesNum = 1, txInsVi = var_int_1.VarInt.fromNumber(0), txIns = [], txOutsVi = var_int_1.VarInt.fromNumber(0), txOuts = [], nLockTime = 0) {
        super({ versionBytesNum, txInsVi, txIns, txOutsVi, txOuts, nLockTime });
    }
    fromJSON(json) {
        const txIns = [];
        for (const txIn of json.txIns) {
            txIns.push(new tx_in_1.TxIn().fromJSON(txIn));
        }
        const txOuts = [];
        for (const txOut of json.txOuts) {
            txOuts.push(new tx_out_1.TxOut().fromJSON(txOut));
        }
        this.fromObject({
            versionBytesNum: json.versionBytesNum,
            txInsVi: new var_int_1.VarInt().fromJSON(json.txInsVi),
            txIns,
            txOutsVi: new var_int_1.VarInt().fromJSON(json.txOutsVi),
            txOuts,
            nLockTime: json.nLockTime,
        });
        return this;
    }
    toJSON() {
        const txIns = [];
        for (const txIn of this.txIns) {
            txIns.push(txIn.toJSON());
        }
        const txOuts = [];
        for (const txOut of this.txOuts) {
            txOuts.push(txOut.toJSON());
        }
        return {
            versionBytesNum: this.versionBytesNum,
            txInsVi: this.txInsVi.toJSON(),
            txIns,
            txOutsVi: this.txOutsVi.toJSON(),
            txOuts,
            nLockTime: this.nLockTime,
        };
    }
    fromBr(br) {
        this.versionBytesNum = br.readUInt32LE();
        this.txInsVi = new var_int_1.VarInt(br.readVarIntBuf());
        const txInsNum = this.txInsVi.toNumber();
        this.txIns = [];
        for (let i = 0; i < txInsNum; i++) {
            this.txIns.push(new tx_in_1.TxIn().fromBr(br));
        }
        this.txOutsVi = new var_int_1.VarInt(br.readVarIntBuf());
        const txOutsNum = this.txOutsVi.toNumber();
        this.txOuts = [];
        for (let i = 0; i < txOutsNum; i++) {
            this.txOuts.push(new tx_out_1.TxOut().fromBr(br));
        }
        this.nLockTime = br.readUInt32LE();
        return this;
    }
    toBw(bw) {
        if (!bw) {
            bw = new bw_1.Bw();
        }
        bw.writeUInt32LE(this.versionBytesNum);
        bw.write(this.txInsVi.buf);
        for (let i = 0; i < this.txIns.length; i++) {
            this.txIns[i].toBw(bw);
        }
        bw.write(this.txOutsVi.buf);
        for (let i = 0; i < this.txOuts.length; i++) {
            this.txOuts[i].toBw(bw);
        }
        bw.writeUInt32LE(this.nLockTime);
        return bw;
    }
    // https://github.com/Bitcoin-UAHF/spec/blob/master/replay-protected-sighash.md
    hashPrevouts() {
        const bw = new bw_1.Bw();
        for (const i in this.txIns) {
            const txIn = this.txIns[i];
            bw.write(txIn.txHashBuf); // outpoint (1/2)
            bw.writeUInt32LE(txIn.txOutNum); // outpoint (2/2)
        }
        return hash_1.Hash.sha256Sha256(bw.toBuffer());
    }
    hashSequence() {
        const bw = new bw_1.Bw();
        for (const i in this.txIns) {
            const txIn = this.txIns[i];
            bw.writeUInt32LE(txIn.nSequence);
        }
        return hash_1.Hash.sha256Sha256(bw.toBuffer());
    }
    hashOutputs() {
        const bw = new bw_1.Bw();
        for (const i in this.txOuts) {
            const txOut = this.txOuts[i];
            bw.write(txOut.toBuffer());
        }
        return hash_1.Hash.sha256Sha256(bw.toBuffer());
    }
    /**
     * For a normal transaction, subScript is usually the scriptPubKey. For a
     * p2sh transaction, subScript is usually the redeemScript. If you're not
     * normal because you're using OP_CODESEPARATORs, you know what to do.
     */
    sighash(nHashType, nIn, subScript, valueBn, flags = 0, hashCache = new hash_cache_1.HashCache()) {
        // console.log({ subScript })
        const buf = this.sighashPreimage(nHashType, nIn, subScript, valueBn, flags, hashCache);
        if (buf.compare(Buffer.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex')) === 0) {
            return buf;
        }
        return new br_1.Br(hash_1.Hash.sha256Sha256(buf)).readReverse();
    }
    async asyncSighash(nHashType, nIn, subScript, valueBn, flags = 0, hashCache) {
        const workersResult = await workers_1.Workers.asyncObjectMethod(this, 'sighash', [
            nHashType,
            nIn,
            subScript,
            valueBn,
            flags,
            hashCache,
        ]);
        return workersResult.resbuf;
    }
    sighashPreimage(nHashType, nIn, subScript, valueBn, flags = 0, hashCache = new hash_cache_1.HashCache()) {
        // start with UAHF part (Bitcoin SV)
        // https://github.com/Bitcoin-UAHF/spec/blob/master/replay-protected-sighash.md
        if (nHashType & sig_1.Sig.SIGHASH_FORKID && flags & Tx.SCRIPT_ENABLE_SIGHASH_FORKID) {
            let hashPrevouts = Buffer.alloc(32, 0);
            let hashSequence = Buffer.alloc(32, 0);
            let hashOutputs = Buffer.alloc(32, 0);
            if (!(nHashType & sig_1.Sig.SIGHASH_ANYONECANPAY)) {
                hashPrevouts = hashCache.prevoutsHashBuf
                    ? hashCache.prevoutsHashBuf
                    : (hashCache.prevoutsHashBuf = this.hashPrevouts());
            }
            if (!(nHashType & sig_1.Sig.SIGHASH_ANYONECANPAY) &&
                (nHashType & 0x1f) !== sig_1.Sig.SIGHASH_SINGLE &&
                (nHashType & 0x1f) !== sig_1.Sig.SIGHASH_NONE) {
                hashSequence = hashCache.sequenceHashBuf
                    ? hashCache.sequenceHashBuf
                    : (hashCache.sequenceHashBuf = this.hashSequence());
            }
            if ((nHashType & 0x1f) !== sig_1.Sig.SIGHASH_SINGLE && (nHashType & 0x1f) !== sig_1.Sig.SIGHASH_NONE) {
                hashOutputs = hashCache.outputsHashBuf
                    ? hashCache.outputsHashBuf
                    : (hashCache.outputsHashBuf = this.hashOutputs());
            }
            else if ((nHashType & 0x1f) === sig_1.Sig.SIGHASH_SINGLE && nIn < this.txOuts.length) {
                hashOutputs = hash_1.Hash.sha256Sha256(this.txOuts[nIn].toBuffer());
            }
            // console.warn('sighash(): txHashBuf', this.txIns[nIn].txHashBuf.toString('hex'))
            // Need to add opCodeSeparator thing here to shorten the subScript
            let lastOCSLocation = 0;
            let i = 0;
            while (i < subScript.chunks.length) {
                const chunk = subScript.chunks[i];
                if (chunk.opCodeNum === 171) {
                    lastOCSLocation = i;
                }
                i++;
            }
            const ocsSeparatedChunks = subScript.chunks.slice(lastOCSLocation);
            const ocsSubScript = new script_1.Script();
            ocsSeparatedChunks.map(chunk => {
                ocsSubScript.chunks.push(chunk);
            });
            const bw = new bw_1.Bw();
            bw.writeUInt32LE(this.versionBytesNum);
            bw.write(hashPrevouts);
            bw.write(hashSequence);
            bw.write(this.txIns[nIn].txHashBuf); // outpoint (1/2)
            bw.writeUInt32LE(this.txIns[nIn].txOutNum); // outpoint (2/2)
            bw.writeVarIntNum(ocsSubScript.toBuffer().length);
            bw.write(ocsSubScript.toBuffer());
            bw.writeUInt64LEBn(valueBn);
            bw.writeUInt32LE(this.txIns[nIn].nSequence);
            bw.write(hashOutputs);
            bw.writeUInt32LE(this.nLockTime);
            bw.writeUInt32LE(nHashType >>> 0);
            return bw.toBuffer();
        }
        // original bitcoin code follows - not related to UAHF (Bitcoin SV)
        const txcopy = this.cloneByBuffer();
        subScript = new script_1.Script().fromBuffer(subScript.toBuffer());
        subScript.removeCodeseparators();
        for (let i = 0; i < txcopy.txIns.length; i++) {
            txcopy.txIns[i] = tx_in_1.TxIn.fromBuffer(txcopy.txIns[i].toBuffer()).setScript(new script_1.Script());
        }
        txcopy.txIns[nIn] = tx_in_1.TxIn.fromBuffer(txcopy.txIns[nIn].toBuffer()).setScript(subScript);
        if ((nHashType & 31) === sig_1.Sig.SIGHASH_NONE) {
            txcopy.txOuts.length = 0;
            txcopy.txOutsVi = var_int_1.VarInt.fromNumber(0);
            for (let i = 0; i < txcopy.txIns.length; i++) {
                if (i !== nIn) {
                    txcopy.txIns[i].nSequence = 0;
                }
            }
        }
        else if ((nHashType & 31) === sig_1.Sig.SIGHASH_SINGLE) {
            // The SIGHASH_SINGLE bug.
            // https://bitcointalk.org/index.php?topic=260595.0
            if (nIn > txcopy.txOuts.length - 1) {
                return Buffer.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex');
            }
            txcopy.txOuts.length = nIn + 1;
            txcopy.txOutsVi = var_int_1.VarInt.fromNumber(nIn + 1);
            for (let i = 0; i < txcopy.txOuts.length; i++) {
                if (i < nIn) {
                    txcopy.txOuts[i] = tx_out_1.TxOut.fromProperties(new bn_1.Bn().fromBuffer(Buffer.from('ffffffffffffffff', 'hex')), new script_1.Script());
                }
            }
            for (let i = 0; i < txcopy.txIns.length; i++) {
                if (i !== nIn) {
                    txcopy.txIns[i].nSequence = 0;
                }
            }
        }
        // else, SIGHASH_ALL
        if (nHashType & sig_1.Sig.SIGHASH_ANYONECANPAY) {
            txcopy.txIns[0] = txcopy.txIns[nIn];
            txcopy.txIns.length = 1;
            txcopy.txInsVi = var_int_1.VarInt.fromNumber(1);
        }
        return new bw_1.Bw().write(txcopy.toBuffer()).writeInt32LE(nHashType).toBuffer();
    }
    async asyncSighashPreimage(nHashType, nIn, subScript, valueBn, flags = 0, hashCache) {
        const workersResult = await workers_1.Workers.asyncObjectMethod(this, 'sighashPreimage', [
            nHashType,
            nIn,
            subScript,
            valueBn,
            flags,
            hashCache,
        ]);
        return workersResult.resbuf;
    }
    // This function returns a signature but does not update any inputs
    sign(keyPair, nHashType = sig_1.Sig.SIGHASH_ALL | sig_1.Sig.SIGHASH_FORKID, nIn, subScript, valueBn, flags = Tx.SCRIPT_ENABLE_SIGHASH_FORKID, hashCache) {
        const hashBuf = this.sighash(nHashType, nIn, subScript, valueBn, flags, hashCache);
        // console.warn('sighash sign', { hashBuf: hashBuf.toString('hex'), subScript })//, pubKey, nHashType: sig.nHashType, nIn, subScript, valueBn, flags })
        const sig = ecdsa_1.Ecdsa.sign(hashBuf, keyPair, 'little').fromObject({
            nHashType,
        });
        return sig;
    }
    async asyncSign(keyPair, nHashType = sig_1.Sig.SIGHASH_ALL | sig_1.Sig.SIGHASH_FORKID, nIn, subScript, valueBn, flags = Tx.SCRIPT_ENABLE_SIGHASH_FORKID, hashCache) {
        const workersResult = await workers_1.Workers.asyncObjectMethod(this, 'sign', [
            keyPair,
            nHashType,
            nIn,
            subScript,
            valueBn,
            flags,
            hashCache,
        ]);
        return new sig_1.Sig().fromFastBuffer(workersResult.resbuf);
    }
    // This function takes a signature as input and does not parse any inputs
    verify(sig, pubKey, nIn, subScript, enforceLowS = false, valueBn, flags = Tx.SCRIPT_ENABLE_SIGHASH_FORKID, hashCache) {
        const hashBuf = this.sighash(sig.nHashType, nIn, subScript, valueBn, flags, hashCache);
        //  console.warn('sighash verify', { hashBuf: hashBuf.toString('hex'), subScript })//, pubKey, nHashType: sig.nHashType, nIn, subScript, valueBn, flags })
        return ecdsa_1.Ecdsa.verify(hashBuf, sig, pubKey, 'little', enforceLowS);
    }
    async asyncVerify(sig, pubKey, nIn, subScript, enforceLowS = false, valueBn, flags = Tx.SCRIPT_ENABLE_SIGHASH_FORKID, hashCache) {
        const workersResult = await workers_1.Workers.asyncObjectMethod(this, 'verify', [
            sig,
            pubKey,
            nIn,
            subScript,
            enforceLowS,
            valueBn,
            flags,
            hashCache,
        ]);
        return JSON.parse(workersResult.resbuf.toString());
    }
    hash() {
        return hash_1.Hash.sha256Sha256(this.toBuffer());
    }
    async asyncHash() {
        const workersResult = await workers_1.Workers.asyncObjectMethod(this, 'hash', []);
        return workersResult.resbuf;
    }
    id() {
        return new br_1.Br(this.hash()).readReverse().toString('hex');
    }
    async asyncId() {
        const workersResult = await workers_1.Workers.asyncObjectMethod(this, 'id', []);
        return JSON.parse(workersResult.resbuf.toString());
    }
    addTxIn(txHashBuf, txOutNum, script, nSequence) {
        let txIn;
        if (txHashBuf instanceof tx_in_1.TxIn) {
            txIn = txHashBuf;
        }
        else {
            txIn = new tx_in_1.TxIn().fromObject({ txHashBuf, txOutNum, nSequence }).setScript(script);
        }
        this.txIns.push(txIn);
        this.txInsVi = var_int_1.VarInt.fromNumber(this.txInsVi.toNumber() + 1);
        return this;
    }
    addTxOut(valueBn, script) {
        let txOut;
        if (valueBn instanceof tx_out_1.TxOut) {
            txOut = valueBn;
        }
        else {
            txOut = new tx_out_1.TxOut().fromObject({ valueBn }).setScript(script);
        }
        this.txOuts.push(txOut);
        this.txOutsVi = var_int_1.VarInt.fromNumber(this.txOutsVi.toNumber() + 1);
        return this;
    }
    /**
     * Analagous to bitcoind's IsCoinBase function in transaction.h
     */
    isCoinbase() {
        return this.txIns.length === 1 && this.txIns[0].hasNullInput();
    }
    /**
     * BIP 69 sorting. Be sure to sign after sorting.
     */
    sort() {
        this.txIns.sort((first, second) => {
            return (new br_1.Br(first.txHashBuf).readReverse().compare(new br_1.Br(second.txHashBuf).readReverse()) ||
                first.txOutNum - second.txOutNum);
        });
        this.txOuts.sort((first, second) => {
            return (first.valueBn.sub(second.valueBn).toNumber() ||
                first.script.toBuffer().compare(second.script.toBuffer()));
        });
        return this;
    }
}
exports.Tx = Tx;
Tx.MAX_MONEY = 21000000 * 1e8;
// This is defined on Interp, but Tx cannot depend on Interp - must redefine here
Tx.SCRIPT_ENABLE_SIGHASH_FORKID = 1 << 16;
//# sourceMappingURL=tx.js.map