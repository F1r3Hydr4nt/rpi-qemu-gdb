"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxVerifier = void 0;
/**
 * Transaction Verifier
 * ====================
 */
const block_1 = require("./block");
const bn_1 = require("./bn");
const interp_1 = require("./interp");
const struct_1 = require("./struct");
const tx_1 = require("./tx");
const workers_1 = require("./workers");
class TxVerifier extends struct_1.Struct {
    constructor(tx, txOutMap, errStr, interps) {
        super({ tx, txOutMap, errStr, interps });
        this.interps = interps || []; // Ensure interps is always an array
    }
    /**
     * Verifies that the transaction is valid both by performing basic checks, such
     * as ensuring that no two inputs are the same, as well as by verifying every
     * script. The two checks are checkStr, which is analagous to bitcoind's
     * CheckTransaction, and verifyStr, which runs the script interpreter.
     *
     * This does NOT check that any possible claimed fees are accurate; checking
     * that the fees are accurate requires checking that the input transactions are
     * valid, which is not performed by this test. That check is done with the
     * normal verify function.
     */
    verify(flags = interp_1.Interp.SCRIPT_ENABLE_SIGHASH_FORKID) {
        const basicChecks = this.checkStr();
        const verStr = this.verifyStr(flags);
        // console.log({ basicChecks, verStr })
        return !basicChecks && !verStr;
    }
    /*
     * Returns true if the transaction was verified successfully (that is no
     * error was found), and false otherwise. In case an error was found the
     * error message can be accessed by calling this.getDebugString().
     */
    async asyncVerify(flags) {
        const verifyStr = await this.asyncVerifyStr(flags);
        return !this.checkStr() && !verifyStr;
    }
    /**
     * Convenience method to verify a transaction.
     */
    static verify(tx, txOutMap, flags) {
        return new TxVerifier(tx, txOutMap).verify(flags);
    }
    static asyncVerify(tx, txOutMap, flags) {
        return new TxVerifier(tx, txOutMap).asyncVerify(flags);
    }
    /**
     * Check that a transaction passes basic sanity tests. If not, return a string
     * describing the error. This function contains the same logic as
     * CheckTransaction in bitcoin core.
     */
    checkStr() {
        // Basic checks that don't depend on any context
        if (this.tx.txIns.length === 0 || this.tx.txInsVi.toNumber() === 0) {
            this.errStr = 'transaction txIns empty';
            return this.errStr;
        }
        if (this.tx.txOuts.length === 0 || this.tx.txOutsVi.toNumber() === 0) {
            this.errStr = 'transaction txOuts empty';
            return this.errStr;
        }
        // Size limits
        if (this.tx.toBuffer().length > block_1.Block.MAX_BLOCK_SIZE) {
            this.errStr = 'transaction over the maximum block size';
            return this.errStr;
        }
        // Check for negative or overflow output values
        let valueoutbn = new bn_1.Bn(0);
        for (let i = 0; i < this.tx.txOuts.length; i++) {
            const txOut = this.tx.txOuts[i];
            if (txOut.valueBn.lt(0)) {
                this.errStr = 'transaction txOut ' + i + ' negative';
                return this.errStr;
            }
            if (txOut.valueBn.gt(tx_1.Tx.MAX_MONEY)) {
                this.errStr = 'transaction txOut ' + i + ' greater than MAX_MONEY';
                return this.errStr;
            }
            valueoutbn = valueoutbn.add(txOut.valueBn);
            if (valueoutbn.gt(tx_1.Tx.MAX_MONEY)) {
                this.errStr = 'transaction txOut ' + i + ' total output greater than MAX_MONEY';
                return this.errStr;
            }
        }
        // Check for duplicate inputs
        const txInmap = {};
        for (let i = 0; i < this.tx.txIns.length; i++) {
            const txIn = this.tx.txIns[i];
            const inputid = txIn.txHashBuf.toString('hex') + ':' + txIn.txOutNum;
            if (txInmap[inputid] !== undefined) {
                this.errStr = 'transaction input ' + i + ' duplicate input';
                return this.errStr;
            }
            txInmap[inputid] = true;
        }
        if (this.tx.isCoinbase()) {
            const buf = this.tx.txIns[0].script.toBuffer();
            if (buf.length < 2 || buf.length > 100) {
                this.errStr = 'coinbase trasaction script size invalid';
                return this.errStr;
            }
        }
        else {
            for (let i = 0; i < this.tx.txIns.length; i++) {
                if (this.tx.txIns[i].hasNullInput()) {
                    this.errStr = 'transaction input ' + i + ' has null input';
                    return this.errStr;
                }
            }
        }
        return false;
    }
    /**
     * verify the transaction inputs by running the script interpreter. Returns a
     * string of the script interpreter is invalid, otherwise returns false.
     */
    verifyStr(flags) {
        for (let i = 0; i < this.tx.txIns.length; i++) {
            if (!this.verifyNIn(i, flags)) {
                this.errStr = 'input ' + i + ' failed script verify';
                return this.errStr;
            }
        }
        return false;
    }
    async asyncVerifyStr(flags) {
        for (let i = 0; i < this.tx.txIns.length; i++) {
            const verifyNIn = await this.asyncVerifyNIn(i, flags);
            if (!verifyNIn) {
                this.errStr = 'input ' + i + ' failed script verify';
                return this.errStr;
            }
        }
        return false;
    }
    /**
     * Verify a particular input by running the script interpreter. Returns true if
     * the input is valid, false otherwise.
     */
    verifyNIn(nIn, flags) {
        const txIn = this.tx.txIns[nIn];
        const scriptSig = txIn.script;
        const txOut = this.txOutMap.get(txIn.txHashBuf, txIn.txOutNum);
        if (!txOut) {
            console.error('output ' + txIn.txOutNum + ' not found');
            return false;
        }
        const scriptPubKey = txOut.script;
        // console.log({scriptSig, scriptPubKey})
        const valueBn = txOut.valueBn;
        const i = new interp_1.Interp();
        const verified = i.verify(scriptSig, scriptPubKey, this.tx, nIn, flags, valueBn);
        this.interps.push(i);
        return verified;
    }
    async asyncVerifyNIn(nIn, flags) {
        const txIn = this.tx.txIns[nIn];
        // console.log({ txIn, txOutMap: this.txOutMap })
        const scriptSig = txIn.script;
        const txOut = this.txOutMap.get(txIn.txHashBuf, txIn.txOutNum);
        if (!txOut) {
            console.log('output ' + txIn.txOutNum + ' not found');
            return false;
        }
        const scriptPubKey = txOut.script;
        const valueBn = txOut.valueBn;
        const i = new interp_1.Interp();
        const workersResult = await workers_1.Workers.asyncObjectMethod(i, 'verify', [
            scriptSig,
            scriptPubKey,
            this.tx,
            nIn,
            flags,
            valueBn,
        ]);
        const verified = JSON.parse(workersResult.resbuf.toString());
        this.interps.push(i);
        return verified;
    }
    getDebugObject() {
        var _a;
        return {
            errStr: this.errStr,
            interpObjs: (_a = this.interps) === null || _a === void 0 ? void 0 : _a.map(interp => interp ? interp === null || interp === void 0 ? void 0 : interp.getDebugObject() : undefined),
        };
    }
    getDebugString() {
        return JSON.stringify(this === null || this === void 0 ? void 0 : this.getDebugObject(), null, 2);
    }
}
exports.TxVerifier = TxVerifier;
//# sourceMappingURL=tx-verifier.js.map