"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ecies = void 0;
/**
 * Ecies
 * =====
 */
const aescbc_1 = require("./aescbc");
const cmp_1 = require("./cmp");
const hash_1 = require("./hash");
const key_pair_1 = require("./key-pair");
const point_1 = require("./point");
const pub_key_1 = require("./pub-key");
const random_1 = require("./random");
const workers_1 = require("./workers");
class Ecies {
    static ivkEkM(privKey, pubKey) {
        const r = privKey.bn;
        const KB = pubKey.point;
        const P = KB.mul(r);
        const S = new pub_key_1.PubKey(P);
        const Sbuf = S.toBuffer();
        const hash = hash_1.Hash.sha512(Sbuf);
        return {
            iv: hash.slice(0, 16),
            kE: hash.slice(16, 32),
            kM: hash.slice(32, 64),
        };
    }
    static electrumEncrypt(messageBuf, toPubKey, fromKeyPair, noKey = false) {
        if (!Buffer.isBuffer(messageBuf)) {
            throw new Error('messageBuf must be a buffer');
        }
        let Rbuf;
        if (fromKeyPair === null) {
            fromKeyPair = key_pair_1.KeyPair.fromRandom();
        }
        if (!noKey) {
            Rbuf = fromKeyPair.pubKey.toDer(true);
        }
        const { iv, kE, kM } = Ecies.ivkEkM(fromKeyPair.privKey, toPubKey);
        const ciphertext = aescbc_1.Aescbc.encrypt(messageBuf, kE, iv, false);
        const BIE1 = Buffer.from('BIE1');
        let encBuf;
        if (Rbuf) {
            encBuf = Buffer.concat([BIE1, Rbuf, ciphertext]);
        }
        else {
            encBuf = Buffer.concat([BIE1, ciphertext]);
        }
        const hmac = hash_1.Hash.sha256Hmac(encBuf, kM);
        return Buffer.concat([encBuf, hmac]);
    }
    static electrumDecrypt(encBuf, toPrivKey, fromPubKey = null) {
        if (!Buffer.isBuffer(encBuf)) {
            throw new Error('encBuf must be a buffer');
        }
        const tagLength = 32;
        const magic = encBuf.slice(0, 4);
        if (!magic.equals(Buffer.from('BIE1'))) {
            throw new Error('Invalid Magic');
        }
        let offset = 4;
        if (fromPubKey === null) {
            // BIE1 use compressed public key, length is always 33.
            const pub = encBuf.slice(4, 37);
            fromPubKey = pub_key_1.PubKey.fromDer(pub);
            offset = 37;
        }
        const { iv, kE, kM } = Ecies.ivkEkM(toPrivKey, fromPubKey);
        const ciphertext = encBuf.slice(offset, encBuf.length - tagLength);
        const hmac = encBuf.slice(encBuf.length - tagLength, encBuf.length);
        const hmac2 = hash_1.Hash.sha256Hmac(encBuf.slice(0, encBuf.length - tagLength), kM);
        if (!hmac.equals(hmac2)) {
            throw new Error('Invalid checksum');
        }
        return aescbc_1.Aescbc.decrypt(ciphertext, kE, iv);
    }
    static bitcoreEncrypt(messageBuf, toPubKey, fromKeyPair, ivBuf) {
        if (!fromKeyPair) {
            fromKeyPair = key_pair_1.KeyPair.fromRandom();
        }
        const r = fromKeyPair.privKey.bn;
        const RPubKey = fromKeyPair.pubKey;
        const RBuf = RPubKey.toDer(true);
        const KB = toPubKey.point;
        const P = KB.mul(r);
        const S = P.getX();
        const Sbuf = S.toBuffer({ size: 32 });
        const kEkM = hash_1.Hash.sha512(Sbuf);
        const kE = kEkM.slice(0, 32);
        const kM = kEkM.slice(32, 64);
        const c = aescbc_1.Aescbc.encrypt(messageBuf, kE, ivBuf);
        const d = hash_1.Hash.sha256Hmac(c, kM);
        const encBuf = Buffer.concat([RBuf, c, d]);
        return encBuf;
    }
    static async asyncBitcoreEncrypt(messageBuf, toPubKey, fromKeyPair, ivBuf) {
        if (!fromKeyPair) {
            fromKeyPair = await key_pair_1.KeyPair.asyncFromRandom();
        }
        if (!ivBuf) {
            ivBuf = random_1.Random.getRandomBuffer(128 / 8);
        }
        const args = [messageBuf, toPubKey, fromKeyPair, ivBuf];
        const workersResult = await workers_1.Workers.asyncClassMethod(Ecies, 'bitcoreEncrypt', args);
        return workersResult.resbuf;
    }
    static bitcoreDecrypt(encBuf, toPrivKey) {
        const kB = toPrivKey.bn;
        const fromPubKey = pub_key_1.PubKey.fromDer(encBuf.slice(0, 33));
        const R = fromPubKey.point;
        const P = R.mul(kB);
        if (P.eq(new point_1.Point())) {
            throw new Error('P equals 0');
        }
        const S = P.getX();
        const Sbuf = S.toBuffer({ size: 32 });
        const kEkM = hash_1.Hash.sha512(Sbuf);
        const kE = kEkM.slice(0, 32);
        const kM = kEkM.slice(32, 64);
        const c = encBuf.slice(33, encBuf.length - 32);
        const d = encBuf.slice(encBuf.length - 32, encBuf.length);
        const d2 = hash_1.Hash.sha256Hmac(c, kM);
        if (!(0, cmp_1.cmp)(d, d2)) {
            throw new Error('Invalid checksum');
        }
        const messageBuf = aescbc_1.Aescbc.decrypt(c, kE);
        return messageBuf;
    }
    static async asyncBitcoreDecrypt(encBuf, toPrivKey) {
        const args = [encBuf, toPrivKey];
        const workersResult = await workers_1.Workers.asyncClassMethod(Ecies, 'bitcoreDecrypt', args);
        return workersResult.resbuf;
    }
}
exports.Ecies = Ecies;
//# sourceMappingURL=ecies.js.map