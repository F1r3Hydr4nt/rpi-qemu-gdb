"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrivKey = void 0;
/**
 * Private Key
 * ===========
 *
 * A private key is used for signing transactions (or messages). The primary
 * way to use this is new PrivKey().fromRandom(), or new PrivKey().fromBuffer(buf).
 */
const base_58_check_1 = require("./base-58-check");
const bn_1 = require("./bn");
const constants_1 = require("./constants");
const point_1 = require("./point");
const random_1 = require("./random");
const struct_1 = require("./struct");
class PrivKey extends struct_1.Struct {
    constructor(bn, compressed, constants) {
        super({ bn, compressed });
        constants = constants || constants_1.Constants.Default.PrivKey;
        this.Constants = constants;
    }
    fromJSON(json) {
        this.fromHex(json);
        return this;
    }
    toJSON() {
        return this.toHex();
    }
    fromRandom() {
        let privBuf;
        let bn;
        let condition;
        do {
            privBuf = random_1.Random.getRandomBuffer(32);
            bn = new bn_1.Bn().fromBuffer(privBuf);
            condition = bn.lt(point_1.Point.getN());
        } while (!condition);
        this.fromObject({
            bn,
            compressed: true,
        });
        return this;
    }
    static fromRandom() {
        return new this().fromRandom();
    }
    toBuffer() {
        let compressed = this.compressed;
        if (compressed === undefined) {
            compressed = true;
        }
        const privBuf = this.bn.toBuffer({ size: 32 });
        let buf;
        if (compressed) {
            buf = Buffer.concat([Buffer.from([this.Constants.versionByteNum]), privBuf, Buffer.from([0x01])]);
        }
        else {
            buf = Buffer.concat([Buffer.from([this.Constants.versionByteNum]), privBuf]);
        }
        return buf;
    }
    fromBuffer(buf) {
        if (buf.length === 1 + 32 + 1 && buf[1 + 32 + 1 - 1] === 1) {
            this.compressed = true;
        }
        else if (buf.length === 1 + 32) {
            this.compressed = false;
        }
        else {
            throw new Error('Length of privKey buffer must be 33 (uncompressed pubKey) or 34 (compressed pubKey)');
        }
        if (buf[0] !== this.Constants.versionByteNum) {
            throw new Error('Invalid versionByteNum byte');
        }
        return this.fromBn(new bn_1.Bn().fromBuffer(buf.slice(1, 1 + 32)));
    }
    toBn() {
        return this.bn;
    }
    fromBn(bn) {
        this.bn = bn;
        return this;
    }
    static fromBn(bn) {
        return new this().fromBn(bn);
    }
    validate() {
        if (!this.bn.lt(point_1.Point.getN())) {
            throw new Error('Number must be less than N');
        }
        if (typeof this.compressed !== 'boolean') {
            throw new Error('Must specify whether the corresponding public key is compressed or not (true or false)');
        }
        return this;
    }
    /**
     * Output the private key a Wallet Import Format (Wif) string.
     */
    toWif() {
        return base_58_check_1.Base58Check.encode(this.toBuffer());
    }
    /**
     * Input the private key from a Wallet Import Format (Wif) string.
     */
    fromWif(str) {
        return this.fromBuffer(base_58_check_1.Base58Check.decode(str));
    }
    static fromWif(str) {
        return new this().fromWif(str);
    }
    toString() {
        return this.toWif();
    }
    fromString(str) {
        return this.fromWif(str);
    }
}
exports.PrivKey = PrivKey;
PrivKey.Mainnet = class extends PrivKey {
    constructor(bn, compressed) {
        super(bn, compressed, constants_1.Constants.Mainnet.PrivKey);
    }
};
PrivKey.Testnet = class extends PrivKey {
    constructor(bn, compressed) {
        super(bn, compressed, constants_1.Constants.Testnet.PrivKey);
    }
};
//# sourceMappingURL=priv-key.js.map