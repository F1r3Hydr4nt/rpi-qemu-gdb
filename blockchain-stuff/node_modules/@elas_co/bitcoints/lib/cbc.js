"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cbc = void 0;
/**
 * Cbc
 * ===
 *
 * Cipher Block Chaining (Cbc). This is a low-level tool for chaining multiple
 * encrypted blocks together, usually with Aes. This is a low-level tool that
 * does not include authentication. You should only be using this if you have
 * authentication at another step. It is best combined with Hmac.
 *
 * http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher-block_chaining_.2829
 */
const cmp_1 = require("./cmp");
class Cbc {
    static buf2BlocksBuf(buf, blockSize) {
        const bytesize = blockSize / 8;
        const blockBufs = [];
        for (let i = 0; i <= buf.length / bytesize; i++) {
            let blockBuf = buf.slice(i * bytesize, i * bytesize + bytesize);
            if (blockBuf.length < blockSize) {
                blockBuf = Cbc.pkcs7Pad(blockBuf, blockSize);
            }
            blockBufs.push(blockBuf);
        }
        return blockBufs;
    }
    static blockBufs2Buf(blockBufs) {
        let last = blockBufs[blockBufs.length - 1];
        last = Cbc.pkcs7Unpad(last);
        blockBufs[blockBufs.length - 1] = last;
        const buf = Buffer.concat(blockBufs);
        return buf;
    }
    static encrypt(messageBuf, ivBuf, blockCipher /* TODO: type */, cipherKeyBuf) {
        const blockSize = ivBuf.length * 8;
        const blockBufs = Cbc.buf2BlocksBuf(messageBuf, blockSize);
        const encBufs = Cbc.encryptBlocks(blockBufs, ivBuf, blockCipher, cipherKeyBuf);
        const encBuf = Buffer.concat(encBufs);
        return encBuf;
    }
    static decrypt(encBuf, ivBuf, blockCipher /* TODO: type */, cipherKeyBuf) {
        const bytesize = ivBuf.length;
        const encBufs = [];
        for (let i = 0; i < encBuf.length / bytesize; i++) {
            encBufs.push(encBuf.slice(i * bytesize, i * bytesize + bytesize));
        }
        const blockBufs = Cbc.decryptBlocks(encBufs, ivBuf, blockCipher, cipherKeyBuf);
        const buf = Cbc.blockBufs2Buf(blockBufs);
        return buf;
    }
    static encryptBlock(blockBuf, ivBuf, blockCipher /* TODO: type */, cipherKeyBuf) {
        const xorbuf = Cbc.xorBufs(blockBuf, ivBuf);
        const encBuf = blockCipher.encrypt(xorbuf, cipherKeyBuf);
        return encBuf;
    }
    static decryptBlock(encBuf, ivBuf, blockCipher /* TODO: type */, cipherKeyBuf) {
        const xorbuf = blockCipher.decrypt(encBuf, cipherKeyBuf);
        const blockBuf = Cbc.xorBufs(xorbuf, ivBuf);
        return blockBuf;
    }
    static encryptBlocks(blockBufs, ivBuf, blockCipher /* TODO: type */, cipherKeyBuf) {
        const encBufs = [];
        for (let i = 0; i < blockBufs.length; i++) {
            const blockBuf = blockBufs[i];
            const encBuf = Cbc.encryptBlock(blockBuf, ivBuf, blockCipher, cipherKeyBuf);
            encBufs.push(encBuf);
            ivBuf = encBuf;
        }
        return encBufs;
    }
    static decryptBlocks(encBufs, ivBuf, blockCipher /* TODO: type */, cipherKeyBuf) {
        const blockBufs = [];
        for (let i = 0; i < encBufs.length; i++) {
            const encBuf = encBufs[i];
            const blockBuf = Cbc.decryptBlock(encBuf, ivBuf, blockCipher, cipherKeyBuf);
            blockBufs.push(blockBuf);
            ivBuf = encBuf;
        }
        return blockBufs;
    }
    static pkcs7Pad(buf, blockSize) {
        const bytesize = blockSize / 8;
        const padbytesize = bytesize - buf.length;
        const pad = Buffer.alloc(padbytesize);
        pad.fill(padbytesize);
        const paddedbuf = Buffer.concat([buf, pad]);
        return paddedbuf;
    }
    static pkcs7Unpad(paddedbuf) {
        const padlength = paddedbuf[paddedbuf.length - 1];
        const padbuf = paddedbuf.slice(paddedbuf.length - padlength, paddedbuf.length);
        const padbuf2 = Buffer.alloc(padlength);
        padbuf2.fill(padlength);
        if (!(0, cmp_1.cmp)(padbuf, padbuf2)) {
            throw new Error('invalid padding');
        }
        return paddedbuf.slice(0, paddedbuf.length - padlength);
    }
    static xorBufs(buf1, buf2) {
        if (buf1.length !== buf2.length) {
            throw new Error('bufs must have the same length');
        }
        const buf = Buffer.alloc(buf1.length);
        for (let i = 0; i < buf1.length; i++) {
            buf[i] = buf1[i] ^ buf2[i];
        }
        return buf;
    }
}
exports.Cbc = Cbc;
//# sourceMappingURL=cbc.js.map