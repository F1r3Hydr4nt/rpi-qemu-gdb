"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Hash = void 0;
/**
 * Hash
 * ====
 *
 * Some hash functions are used through out bitcoin. We expose them here as a
 * convenience.
 */
const hash_js_1 = require("hash.js");
const workers_1 = require("./workers");
class Hash {
    static sha1(buf) {
        if (!Buffer.isBuffer(buf)) {
            throw new Error('sha1 hash must be of a buffer');
        }
        const hash = (0, hash_js_1.sha1)().update(buf).digest();
        return Buffer.from(hash);
    }
    static async asyncSha1(buf) {
        const args = [buf];
        const workersResult = await workers_1.Workers.asyncClassMethod(Hash, 'sha1', args);
        return workersResult.resbuf;
    }
    static sha256(buf) {
        if (!Buffer.isBuffer(buf)) {
            throw new Error('sha256 hash must be of a buffer');
        }
        const hash = (0, hash_js_1.sha256)().update(buf).digest();
        return Buffer.from(hash);
    }
    static async asyncSha256(buf) {
        const args = [buf];
        const workersResult = await workers_1.Workers.asyncClassMethod(Hash, 'sha256', args);
        return workersResult.resbuf;
    }
    static sha256Sha256(buf) {
        try {
            return Hash.sha256(Hash.sha256(buf));
        }
        catch (e) {
            throw new Error('sha256Sha256 hash must be of a buffer: ' + e);
        }
    }
    static async asyncSha256Sha256(buf) {
        const args = [buf];
        const workersResult = await workers_1.Workers.asyncClassMethod(Hash, 'sha256Sha256', args);
        return workersResult.resbuf;
    }
    static ripemd160(buf) {
        if (!Buffer.isBuffer(buf)) {
            throw new Error('ripemd160 hash must be of a buffer');
        }
        const hash = (0, hash_js_1.ripemd160)().update(buf).digest();
        return Buffer.from(hash);
    }
    static async asyncRipemd160(buf) {
        const args = [buf];
        const workersResult = await workers_1.Workers.asyncClassMethod(Hash, 'ripemd160', args);
        return workersResult.resbuf;
    }
    static sha256Ripemd160(buf) {
        try {
            return Hash.ripemd160(Hash.sha256(buf));
        }
        catch (e) {
            throw new Error('sha256Ripemd160 hash must be of a buffer: ' + e);
        }
    }
    static async asyncSha256Ripemd160(buf) {
        const args = [buf];
        const workersResult = await workers_1.Workers.asyncClassMethod(Hash, 'sha256Ripemd160', args);
        return workersResult.resbuf;
    }
    static sha512(buf) {
        if (!Buffer.isBuffer(buf)) {
            throw new Error('sha512 hash must be of a buffer');
        }
        const hash = (0, hash_js_1.sha512)().update(buf).digest();
        return Buffer.from(hash);
    }
    static async asyncSha512(buf) {
        const args = [buf];
        const workersResult = await workers_1.Workers.asyncClassMethod(Hash, 'sha512', args);
        return workersResult.resbuf;
    }
    static hmac(hashFStr, data, key) {
        if (hashFStr !== 'sha1' && hashFStr !== 'sha256' && hashFStr !== 'sha512') {
            throw new Error('invalid choice of hash function');
        }
        const hashf = Hash[hashFStr];
        if (!Buffer.isBuffer(data) || !Buffer.isBuffer(key)) {
            throw new Error('data and key must be buffers');
        }
        // http://en.wikipedia.org/wiki/Hash-based_message_authentication_code
        // http://tools.ietf.org/html/rfc4868#section-2
        const blockSize = Hash.blockSize[hashFStr] / 8;
        if (key.length > blockSize) {
            key = hashf(key);
        }
        if (key.length < blockSize) {
            const fill = Buffer.alloc(blockSize);
            fill.fill(0, key.length);
            key.copy(fill);
            key = fill;
        }
        const oKeyPad = Buffer.alloc(blockSize);
        const iKeyPad = Buffer.alloc(blockSize);
        for (let i = 0; i < blockSize; i++) {
            oKeyPad[i] = 0x5c ^ key[i];
            iKeyPad[i] = 0x36 ^ key[i];
        }
        return hashf(Buffer.concat([oKeyPad, hashf(Buffer.concat([iKeyPad, data]))]));
    }
    static sha1Hmac(data, key) {
        return Hash.hmac('sha1', data, key);
    }
    static async asyncSha1Hmac(data, key) {
        const args = [data, key];
        const workersResult = await workers_1.Workers.asyncClassMethod(Hash, 'sha1Hmac', args);
        return workersResult.resbuf;
    }
    static sha256Hmac(data, key) {
        return Hash.hmac('sha256', data, key);
    }
    static async asyncSha256Hmac(data, key) {
        const args = [data, key];
        const workersResult = await workers_1.Workers.asyncClassMethod(Hash, 'sha256Hmac', args);
        return workersResult.resbuf;
    }
    static sha512Hmac(data, key) {
        return Hash.hmac('sha512', data, key);
    }
    static async asyncSha512Hmac(data, key) {
        const args = [data, key];
        const workersResult = await workers_1.Workers.asyncClassMethod(Hash, 'sha512Hmac', args);
        return workersResult.resbuf;
    }
}
exports.Hash = Hash;
Hash.blockSize = {
    sha1: 512,
    sha256: 512,
    sha512: 1024,
};
Hash.bitsize = {
    sha1Hmac: 160,
    sha256Hmac: 256,
    sha512Hmac: 512,
};
//# sourceMappingURL=hash.js.map