"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Block = void 0;
/**
 * Block
 * =====
 *
 * A block, of course, is a collection of transactions. This class is somewhat
 * incompconste at the moment. In the future, it should support the ability to
 * check to see if a transaction is in a block (thanks to the magic of merkle
 * trees). You will probably never use Yours Bitcoin to create a block, since almost
 * everyone will use bitcoind for that. As such, the primary way to use this is
 * new Block().fromBuffer(buf), which will parse the block and prepare its insides
 * for you to inspect.
 */
const block_header_1 = require("./block-header");
const br_1 = require("./br");
const bw_1 = require("./bw");
const hash_1 = require("./hash");
const merkle_1 = require("./merkle");
const struct_1 = require("./struct");
const tx_1 = require("./tx");
const var_int_1 = require("./var-int");
const workers_1 = require("./workers");
class Block extends struct_1.Struct {
    constructor(blockHeader, txsVi, txs) {
        super({ blockHeader, txsVi, txs });
    }
    fromJSON(json) {
        const txs = [];
        for (const tx of json.txs) {
            txs.push(new tx_1.Tx().fromJSON(tx));
        }
        this.fromObject({
            blockHeader: new block_header_1.BlockHeader().fromJSON(json.blockHeader),
            txsVi: new var_int_1.VarInt().fromJSON(json.txsVi),
            txs,
        });
        return this;
    }
    toJSON() {
        const txs = [];
        for (const tx of txs) {
            txs.push(tx.toJSON());
        }
        return {
            blockHeader: this.blockHeader.toJSON(),
            txsVi: this.txsVi.toJSON(),
            txs,
        };
    }
    fromBr(br) {
        this.blockHeader = new block_header_1.BlockHeader().fromBr(br);
        this.txsVi = new var_int_1.VarInt(br.readVarIntBuf());
        const txsNum = this.txsVi.toNumber();
        this.txs = [];
        for (let i = 0; i < txsNum; i++) {
            this.txs.push(new tx_1.Tx().fromBr(br));
        }
        return this;
    }
    toBw(bw) {
        if (!bw) {
            bw = new bw_1.Bw();
        }
        bw.write(this.blockHeader.toBuffer());
        bw.write(this.txsVi.buf);
        const txsNum = this.txsVi.toNumber();
        for (let i = 0; i < txsNum; i++) {
            this.txs[i].toBw(bw);
        }
        return bw;
    }
    hash() {
        return hash_1.Hash.sha256Sha256(this.blockHeader.toBuffer());
    }
    async asyncHash() {
        const workersResult = await workers_1.Workers.asyncObjectMethod(this, 'hash', []);
        return workersResult.resbuf;
    }
    id() {
        return new br_1.Br(this.hash()).readReverse().toString('hex');
    }
    async asyncId() {
        const workersResult = await workers_1.Workers.asyncObjectMethod(this, 'id', []);
        return JSON.parse(workersResult.resbuf.toString());
    }
    verifyMerkleRoot() {
        const txsbufs = this.txs.map((tx) => tx.toBuffer());
        const merkleRootBuf = merkle_1.Merkle.fromBuffers(txsbufs).hash();
        return Buffer.compare(merkleRootBuf, this.blockHeader.merkleRootBuf);
    }
    /**
     * Sometimes we don't want to parse an entire block into memory. Instead, we
     * simply want to iterate through all transactions in the block. That is what
     * this method is for. This method returns an efficient iterator which can be
     * used in a `for (tx of txs)` construct that returns each tx one at a time
     * without first parsing all of them into memory.
     *
     * @param {Buffer} blockBuf A buffer of a block.
     */
    static iterateTxs(blockBuf) {
        const br = new br_1.Br(blockBuf);
        const blockHeader = new block_header_1.BlockHeader().fromBr(br);
        const txsVi = new var_int_1.VarInt(br.readVarIntBuf());
        const txsNum = txsVi.toNumber();
        return {
            blockHeader,
            txsVi,
            txsNum,
            *[Symbol.iterator]() {
                for (let i = 0; i < txsNum; i++) {
                    yield new tx_1.Tx().fromBr(br);
                }
            },
        };
    }
}
exports.Block = Block;
Block.MAX_BLOCK_SIZE = 1000000;
//# sourceMappingURL=block.js.map