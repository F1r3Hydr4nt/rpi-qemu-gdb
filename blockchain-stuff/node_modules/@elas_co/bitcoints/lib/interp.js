"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Interp = void 0;
/* eslint-disable @typescript-eslint/no-shadow */
/**
 * Script Interpreter
 * ==================
 *
 * Bitcoin transactions contain scripts. Each input has a script called the
 * scriptSig, and each output has a script called the scriptPubKey. To validate
 * an input, the ScriptSig is executed, then with the same stack, the
 * scriptPubKey from the output corresponding to that input is run. The primary
 * way to use this class is via the verify function:
 *
 * new Interp().verify( ... )
 *
 * In some ways, the script interpreter is one of the most poorly architected
 * components of Yours Bitcoin because of the giant switch statement in step(). But
 * that is deliberately so to make it similar to bitcoin core, and thus easier
 * to audit.
 */
const bn_1 = require("./bn");
const bw_1 = require("./bw");
const cmp_1 = require("./cmp");
const hash_1 = require("./hash");
const op_code_1 = require("./op-code");
const pub_key_1 = require("./pub-key");
const script_1 = require("./script");
const sig_1 = require("./sig");
const struct_1 = require("./struct");
const tx_1 = require("./tx");
const tx_in_1 = require("./tx-in");
class Interp extends struct_1.Struct {
    constructor(scriptSig, scriptPubKey, tx, nIn, stack = [], altStack = [], pc = 0, pBeginCodeHash = 0, nOpCount = 0, ifStack = [], errStr = "", flags = Interp.defaultFlags, valueBn = new bn_1.Bn(0), context = "UnlockingScript") {
        super({
            scriptSig,
            scriptPubKey,
            tx,
            nIn,
            stack,
            altStack,
            pc,
            pBeginCodeHash,
            nOpCount,
            ifStack,
            errStr,
            flags,
            valueBn,
            context,
        });
        this.execSteps = [];
    }
    initialize() {
        this.scriptSig = new script_1.Script();
        this.scriptPubKey = new script_1.Script();
        this.stack = [];
        this.altStack = [];
        this.pc = 0;
        this.pBeginCodeHash = 0;
        this.nOpCount = 0;
        this.ifStack = [];
        this.errStr = "";
        this.flags = Interp.defaultFlags;
        this.execSteps = [];
        this.context = "UnlockingScript";
        return this;
    }
    fromJSON(json) {
        this.fromJSONNoTx(json);
        this.tx = json.tx ? new tx_1.Tx().fromJSON(json.tx) : new tx_1.Tx();
        return this;
    }
    /**
     * Convert JSON containing everything but the tx to an interp object.
     */
    fromJSONNoTx(json) {
        this.fromObject({
            scriptSig: json.scriptSig !== undefined
                ? new script_1.Script().fromJSON(json.scriptSig)
                : undefined,
            scriptPubKey: json.scriptPubKey !== undefined
                ? new script_1.Script().fromJSON(json.scriptPubKey)
                : undefined,
            nIn: json.nIn,
        });
        this.stack = [];
        for (const hex of json.stack) {
            this.stack.push(Buffer.from(hex, "hex"));
        }
        this.altStack = [];
        for (const hex of json.altStack) {
            this.altStack.push(Buffer.from(hex, "hex"));
        }
        this.fromObject({
            pc: json.pc,
            pBeginCodeHash: json.pBeginCodeHash,
            nOpCount: json.nOpCount,
            ifStack: json.ifStack,
            errStr: json.errStr,
            flags: json.flags,
        });
        return this;
    }
    fromBr(br) {
        const jsonNoTxBufLEn = br.readVarIntNum();
        const jsonNoTxBuf = br.read(jsonNoTxBufLEn);
        this.fromJSONNoTx(JSON.parse(jsonNoTxBuf.toString()));
        const txbuflen = br.readVarIntNum();
        if (txbuflen > 0) {
            const txbuf = br.read(txbuflen);
            this.tx = new tx_1.Tx().fromFastBuffer(txbuf);
        }
        return this;
    }
    toJSON() {
        const json = this.toJSONNoTx();
        json.tx = this.tx ? this.tx.toJSON() : undefined;
        return json;
    }
    /**
     * Convert everything but the tx to JSON.
     */
    toJSONNoTx() {
        const stack = [];
        for (const buf of this.stack) {
            stack.push(buf.toString("hex"));
        }
        const altStack = [];
        for (const buf of this.altStack) {
            altStack.push(buf.toString("hex"));
        }
        return {
            scriptSig: this.scriptSig ? this.scriptSig.toJSON() : "",
            scriptPubKey: this.scriptPubKey ? this.scriptPubKey.toJSON() : "",
            nIn: this.nIn,
            stack,
            altStack,
            pc: this.pc,
            pBeginCodeHash: this.pBeginCodeHash,
            nOpCount: this.nOpCount,
            ifStack: this.ifStack,
            errStr: this.errStr,
            flags: this.flags,
            context: this.context,
        };
    }
    toBw(bw) {
        if (!bw) {
            bw = new bw_1.Bw();
        }
        const jsonNoTxBuf = Buffer.from(JSON.stringify(this.toJSONNoTx()));
        bw.writeVarIntNum(jsonNoTxBuf.length);
        bw.write(jsonNoTxBuf);
        if (this.tx) {
            const txbuf = this.tx.toFastBuffer();
            bw.writeVarIntNum(txbuf.length);
            bw.write(txbuf);
        }
        else {
            bw.writeVarIntNum(0);
        }
        return bw;
    }
    /**
     * In order to make auduting the script interpreter easier, we use the same
     * constants as bitcoin core, including the flags, which customize the
     * operation of the interpreter.
     */
    static getFlags(flagstr) {
        let flags = 0;
        if (flagstr.indexOf("NONE") !== -1) {
            flags = flags | Interp.SCRIPT_VERIFY_NONE;
        }
        // if (flagstr.indexOf('P2SH') !== -1) {
        //     flags = flags | Interp.SCRIPT_VERIFY_P2SH
        // }
        if (flagstr.indexOf("STRICTENC") !== -1) {
            flags = flags | Interp.SCRIPT_VERIFY_STRICTENC;
        }
        if (flagstr.indexOf("DERSIG") !== -1) {
            flags = flags | Interp.SCRIPT_VERIFY_DERSIG;
        }
        // if (flagstr.indexOf('LOW_S') !== -1) {
        //     flags = flags | Interp.SCRIPT_VERIFY_LOW_S
        // }
        if (flagstr.indexOf("NULLDUMMY") !== -1) {
            flags = flags | Interp.SCRIPT_VERIFY_NULLDUMMY;
        }
        // if (flagstr.indexOf('SIGPUSHONLY') !== -1) {
        //     flags = flags | Interp.SCRIPT_VERIFY_SIGPUSHONLY
        // }
        // if (flagstr.indexOf('MINIMALDATA') !== -1) {
        //     flags = flags | Interp.SCRIPT_VERIFY_MINIMALDATA
        // }
        if (flagstr.indexOf("DISCOURAGE_UPGRADABLE_NOPS") !== -1) {
            flags = flags | Interp.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS;
        }
        // if (flagstr.indexOf('CLEANSTACK') !== -1) {
        //     flags = flags | Interp.SCRIPT_VERIFY_CLEANSTACK
        // }
        if (flagstr.indexOf("CHECKLOCKTIMEVERIFY") !== -1) {
            flags = flags | Interp.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY;
        }
        if (flagstr.indexOf("CHECKSEQUENCEVERIFY") !== -1) {
            flags = flags | Interp.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY;
        }
        if (flagstr.indexOf("SIGHASH_FORKID") !== -1) {
            flags = flags | Interp.SCRIPT_ENABLE_SIGHASH_FORKID;
        }
        return flags;
    }
    static castToBool(buf) {
        for (let i = 0; i < buf.length; i++) {
            if (buf[i] !== 0) {
                // can be negative zero
                if (i === buf.length - 1 && buf[i] === 0x80) {
                    return false;
                }
                return true;
            }
        }
        return false;
    }
    /**
     * Translated from bitcoin core's CheckSigEncoding
     */
    checkSigEncoding(buf) {
        // Empty signature. Not strictly DER encoded, but allowed to provide a
        // compact way to provide an invalid signature for use with CHECK(MULTI)SIG
        if (buf.length === 0) {
            return true;
        }
        if ((this.flags &
            (Interp.SCRIPT_VERIFY_DERSIG |
                //| Interp.SCRIPT_VERIFY_LOW_S
                Interp.SCRIPT_VERIFY_STRICTENC)) !==
            0 &&
            !sig_1.Sig.IsTxDer(buf)) {
            this.errStr = "SCRIPT_ERR_SIG_DER";
            return false;
        } // else if ((this.flags & Interp.SCRIPT_VERIFY_LOW_S) !== 0) {
        //     const sig = new Sig().fromTxFormat(buf)
        //     if (!sig.hasLowS()) {
        //         this.errStr = 'SCRIPT_ERR_SIG_DER_HIGH_S'
        //         return false
        //     }
        // }
        else if ((this.flags & Interp.SCRIPT_VERIFY_STRICTENC) !== 0) {
            const sig = new sig_1.Sig().fromTxFormat(buf);
            if (!sig.hasDefinedHashType()) {
                this.errStr = "SCRIPT_ERR_SIG_HASHTYPE";
                return false;
            }
        }
        return true;
    }
    /**
     * Translated from bitcoin core's CheckPubKeyEncoding
     */
    checkPubKeyEncoding(buf) {
        if ((this.flags & Interp.SCRIPT_VERIFY_STRICTENC) !== 0 &&
            !pub_key_1.PubKey.isCompressedOrUncompressed(buf)) {
            this.errStr = "SCRIPT_ERR_PUBKEYTYPE";
            return false;
        }
        return true;
    }
    /**
     * Translated from bitcoin core's CheckLockTime
     */
    checkLockTime(nLockTime) {
        // There are two kinds of nLockTime: lock-by-blockheight
        // and lock-by-blocktime, distinguished by whether
        // nLockTime < LOCKTIME_THRESHOLD.
        //
        // We want to compare apples to apples, so fail the script
        // unless the type of nLockTime being tested is the same as
        // the nLockTime in the transaction.
        if (!((this.tx.nLockTime < Interp.LOCKTIME_THRESHOLD &&
            nLockTime < Interp.LOCKTIME_THRESHOLD) ||
            (this.tx.nLockTime >= Interp.LOCKTIME_THRESHOLD &&
                nLockTime >= Interp.LOCKTIME_THRESHOLD))) {
            return false;
        }
        // Now that we know we're comparing apples-to-apples, the
        // comparison is a simple numeric one.
        if (nLockTime > this.tx.nLockTime) {
            return false;
        }
        // Finally the nLockTime feature can be disabled and thus
        // CHECKLOCKTIMEVERIFY bypassed if every txIn has been
        // finalized by setting nSequence to maxint. The
        // transaction would be allowed into the blockchain, making
        // the opCode ineffective.
        //
        // Testing if this vin is not final is sufficient to
        // prevent this condition. Alternatively we could test all
        // inputs, but testing just this input minimizes the data
        // required to prove correct CHECKLOCKTIMEVERIFY execution.
        if (tx_in_1.TxIn.SEQUENCE_FINAL === this.tx.txIns[this.nIn].nSequence) {
            return false;
        }
        return true;
    }
    /**
     * Translated from bitcoin core's CheckSequence.
     */
    checkSequence(nSequence) {
        // Relative lock times are supported by comparing the passed
        // in operand to the sequence number of the input.
        const txToSequence = this.tx.txIns[this.nIn].nSequence;
        // Fail if the transaction's version number is not set high
        // enough to trigger Bip 68 rules.
        if (this.tx.versionBytesNum < 2) {
            return false;
        }
        // Sequence numbers with their most significant bit set are not
        // consensus constrained. Testing that the transaction's sequence
        // number do not have this bit set prevents using this property
        // to get around a CHECKSEQUENCEVERIFY check.
        if (txToSequence & tx_in_1.TxIn.SEQUENCE_LOCKTIME_DISABLE_FLAG) {
            return false;
        }
        // Mask off any bits that do not have consensus-enforced meaning
        // before doing the integer comparisons
        const nLockTimeMask = tx_in_1.TxIn.SEQUENCE_LOCKTIME_TYPE_FLAG | tx_in_1.TxIn.SEQUENCE_LOCKTIME_MASK;
        const txToSequenceMasked = txToSequence & nLockTimeMask;
        const nSequenceMasked = nSequence & nLockTimeMask;
        // There are two kinds of nSequence: lock-by-blockheight
        // and lock-by-blocktime, distinguished by whether
        // nSequenceMasked < CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG.
        //
        // We want to compare apples to apples, so fail the script
        // unless the type of nSequenceMasked being tested is the same as
        // the nSequenceMasked in the transaction.
        if (!((txToSequenceMasked < tx_in_1.TxIn.SEQUENCE_LOCKTIME_TYPE_FLAG &&
            nSequenceMasked < tx_in_1.TxIn.SEQUENCE_LOCKTIME_TYPE_FLAG) ||
            (txToSequenceMasked >= tx_in_1.TxIn.SEQUENCE_LOCKTIME_TYPE_FLAG &&
                nSequenceMasked >= tx_in_1.TxIn.SEQUENCE_LOCKTIME_TYPE_FLAG))) {
            return false;
        }
        // Now that we know we're comparing apples-to-apples, the
        // comparison is a simple numeric one.
        if (nSequenceMasked > txToSequenceMasked) {
            return false;
        }
        return true;
    }
    /**
     * Based on bitcoin core's EvalScript function, with the inner loop moved to
     * Interp.prototype.step()
     * bitcoin core commit: b5d1b1092998bc95313856d535c632ea5a8f9104
     */
    *eval() {
        // if (this.script.toBuffer().length > 10000) {
        //     this.errStr = 'SCRIPT_ERR_SCRIPT_SIZE'
        //     yield false
        // }
        try {
            while (true) {
                //this.pc < this.scriptPubKey?.chunks?.length) {
                const fSuccess = this.step();
                if (!fSuccess) {
                    yield false;
                }
                else {
                    yield fSuccess;
                }
                if (this.context === "LockingScript" &&
                    this.pc >= this.scriptPubKey.chunks.length) {
                    break;
                }
            }
            this.execSteps.push({ pc: this.pc, stack: this.stack.slice(), alt: this.altStack.slice(), ifStack: this.ifStack.slice(), curOp: undefined }); //, context: this.context });
            // this.execSteps.push({ pc: this.pc, stack: this.stack?.slice(), alt: this.altStack?.slice(), ifStack: this.ifStack?.slice(), curOp: this?.scriptPubKey?.chunks?.[this?.pc || 0] })
            // Size limits
            // if (this.stack.length + this.altStack.length > 1000) {
            //     this.errStr = 'SCRIPT_ERR_STACK_SIZE'
            //     yield false
            // }
        }
        catch (e) {
            this.errStr = "SCRIPT_ERR_UNKNOWN_ERROR: " + e;
            yield false;
        }
        if (this.ifStack.length > 0) {
            this.errStr = "SCRIPT_ERR_UNBALANCED_CONDITIONAL";
            yield false;
        }
        yield true;
    }
    /**
     * Based on the inner loop of bitcoin core's EvalScript function
     */
    step() {
        var _a, _b;
        const fRequireMinimal = false; // (this.flags & Interp.SCRIPT_VERIFY_MINIMALDATA) !== 0
        // bool fExec = !count(ifStack.begin(), ifStack.end(), false)
        const fExec = !(this.ifStack.indexOf(false) + 1);
        // If the context is UnlockingScript and we have reached the end,
        // set the context to LockingScript and zero the program counter
        if (this.context === "UnlockingScript" &&
            this.pc >= this.scriptSig.chunks.length) {
            this.context = "LockingScript";
            this.pc = 0;
            // console.log("Switching from scriptSig to scriptPubKey")//,this.scriptPubKey.chunks.length)
            if (this.ifStack.length // "IF/ENDIF can't span scriptSig/scriptPubKey"
            // || this.altStack.length // 'alt stack not shared between sig/pubkey'
            ) {
                return false;
            }
            this.altStack = []; // Reset alt stack
            if (this.scriptPubKey.chunks.length === 0) {
                // console.log("Empty scriptPubKey")
                return true;
            }
        }
        let chunk;
        if (this.context === "UnlockingScript") {
            chunk = this.scriptSig.chunks[this.pc];
        }
        else {
            chunk = this.scriptPubKey.chunks[this.pc];
        }
        this.execSteps.push({ pc: this.pc, stack: this.stack.slice(), alt: this.altStack.slice(), ifStack: this.ifStack.slice(), curOp: chunk, context: this.context });
        // console.log("step", this.context, chunk, this.stack);
        //console.log('step',chunk)
        //
        // Read instruction
        //
        // const chunk = this.scriptPubKey?.chunks?.[this.pc]
        this.pc++;
        const opCodeNum = chunk === null || chunk === void 0 ? void 0 : chunk.opCodeNum;
        if (opCodeNum === undefined) {
            this.errStr = "SCRIPT_ERR_BAD_OPCODE";
            return false;
        }
        // if (chunk.buf && chunk.buf.length > Interp.MAX_SCRIPT_ELEMENT_SIZE) {
        //     this.errStr = 'SCRIPT_ERR_PUSH_SIZE'
        //     return false
        // }
        // // Note how OpCode.OP_RESERVED does not count towards the opCode limit.
        // if (opCodeNum > OpCode.OP_16 && ++this.nOpCount > 201) {
        //     this.errStr = 'SCRIPT_ERR_OP_COUNT'
        //     return false
        // }
        if (
        // opCodeNum === OpCode.OP_LEFT ||
        // opCodeNum === OpCode.OP_RIGHT ||
        opCodeNum === op_code_1.OpCode.OP_2MUL ||
            opCodeNum === op_code_1.OpCode.OP_2DIV) {
            this.errStr = "SCRIPT_ERR_DISABLED_OPCODE";
            return false;
        }
        if (fExec && opCodeNum >= 0 && opCodeNum <= op_code_1.OpCode.OP_PUSHDATA4) {
            // if (fRequireMinimal && !this.script.checkMinimalPush(this.pc - 1)) {
            //     this.errStr = 'SCRIPT_ERR_MINIMALDATA'
            //     return false
            // }
            if (!chunk.buf) {
                this.stack.push(Interp.false);
            }
            else if (chunk.len !== chunk.buf.length) {
                console.warn(chunk.len, chunk.buf);
                throw new Error("LEngth of push value not equal to length of data");
            }
            else {
                this.stack.push(chunk.buf);
            }
        }
        else if (fExec ||
            (op_code_1.OpCode.OP_IF <= opCodeNum && opCodeNum <= op_code_1.OpCode.OP_ENDIF)) {
            switch (opCodeNum) {
                //
                // Push value
                //
                case op_code_1.OpCode.OP_1NEGATE:
                case op_code_1.OpCode.OP_1:
                case op_code_1.OpCode.OP_2:
                case op_code_1.OpCode.OP_3:
                case op_code_1.OpCode.OP_4:
                case op_code_1.OpCode.OP_5:
                case op_code_1.OpCode.OP_6:
                case op_code_1.OpCode.OP_7:
                case op_code_1.OpCode.OP_8:
                case op_code_1.OpCode.OP_9:
                case op_code_1.OpCode.OP_10:
                case op_code_1.OpCode.OP_11:
                case op_code_1.OpCode.OP_12:
                case op_code_1.OpCode.OP_13:
                case op_code_1.OpCode.OP_14:
                case op_code_1.OpCode.OP_15:
                case op_code_1.OpCode.OP_16:
                    {
                        // ( -- value)
                        // ScriptNum bn((int)opCode - (int)(OpCode.OP_1 - 1))
                        const n = opCodeNum - (op_code_1.OpCode.OP_1 - 1);
                        const buf = new bn_1.Bn(n).toScriptNumBuffer();
                        this.stack.push(buf);
                        // The result of these opCodes should always be the minimal way to push the data
                        // they push, so no need for a CheckMinimalPush here.
                    }
                    break;
                //
                // Control
                //
                case op_code_1.OpCode.OP_NOP:
                    break;
                case op_code_1.OpCode.OP_CHECKLOCKTIMEVERIFY:
                    {
                        if (!(this.flags & Interp.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)) {
                            // not enabled; treat as a NOP2
                            if (this.flags & Interp.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {
                                this.errStr = "SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS";
                                return false;
                            }
                            break;
                        }
                        if (this.stack.length < 1) {
                            this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                            return false;
                        }
                        // Note that elsewhere numeric opCodes are limited to
                        // operands in the range -2**31+1 to 2**31-1, however it is
                        // legal for opCodes to produce results exceeding that
                        // range. This limitation is implemented by CScriptNum's
                        // default 4-byte limit.
                        //
                        // If we kept to that limit we'd have a year 2038 problem,
                        // even though the nLockTime field in transactions
                        // themselves is uint32 which only becomes meaningless
                        // after the year 2106.
                        //
                        // Thus as a special case we tell CScriptNum to accept up
                        // to 5-byte bignums, which are good until 2**39-1, well
                        // beyond the 2**32-1 limit of the nLockTime field itself.
                        const nLockTimebuf = this.stack[this.stack.length - 1];
                        const nLockTimebn = new bn_1.Bn().fromScriptNumBuffer(nLockTimebuf, fRequireMinimal, 5);
                        const nLockTime = nLockTimebn.toNumber();
                        // In the rare event that the argument may be < 0 due to
                        // some arithmetic being done first, you can always use
                        // 0 MAX CHECKLOCKTIMEVERIFY.
                        if (nLockTime < 0) {
                            this.errStr = "SCRIPT_ERR_NEGATIVE_LOCKTIME";
                            return false;
                        }
                        // Actually compare the specified lock time with the transaction.
                        if (!this.checkLockTime(nLockTime)) {
                            this.errStr = "SCRIPT_ERR_UNSATISFIED_LOCKTIME";
                            return false;
                        }
                    }
                    break;
                case op_code_1.OpCode.OP_CHECKSEQUENCEVERIFY:
                    {
                        if (!(this.flags & Interp.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)) {
                            // not enabled; treat as a NOP3
                            if (this.flags & Interp.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {
                                this.errStr = "SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS";
                                return false;
                            }
                            break;
                        }
                        if (this.stack.length < 1) {
                            this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                            return false;
                        }
                        // nSequence, like nLockTime, is a 32-bit unsigned integer
                        // field. See the comment in CHECKLOCKTIMEVERIFY regarding
                        // 5-byte numeric operands.
                        const nSequencebuf = this.stack[this.stack.length - 1];
                        const nSequencebn = new bn_1.Bn().fromScriptNumBuffer(nSequencebuf, fRequireMinimal, 5);
                        const nSequence = nSequencebn.toNumber();
                        // In the rare event that the argument may be < 0 due to
                        // some arithmetic being done first, you can always use
                        // 0 MAX CHECKSEQUENCEVERIFY.
                        if (nSequence < 0) {
                            this.errStr = "SCRIPT_ERR_NEGATIVE_LOCKTIME";
                            return false;
                        }
                        // To provide for future soft-fork extensibility, if the
                        // operand has the disabled lock-time flag set,
                        // CHECKSEQUENCEVERIFY behaves as a NOP.
                        if ((nSequence & tx_in_1.TxIn.SEQUENCE_LOCKTIME_DISABLE_FLAG) !== 0) {
                            break;
                        }
                        // Compare the specified sequence number with the input.
                        if (!this.checkSequence(nSequence)) {
                            this.errStr = "SCRIPT_ERR_UNSATISFIED_LOCKTIME";
                            return false;
                        }
                    }
                    break;
                case op_code_1.OpCode.OP_NOP1:
                case op_code_1.OpCode.OP_NOP3:
                case op_code_1.OpCode.OP_NOP4:
                case op_code_1.OpCode.OP_NOP5:
                case op_code_1.OpCode.OP_NOP6:
                case op_code_1.OpCode.OP_NOP7:
                case op_code_1.OpCode.OP_NOP8:
                case op_code_1.OpCode.OP_NOP9:
                case op_code_1.OpCode.OP_NOP10:
                    if (this.flags & Interp.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {
                        this.errStr = "SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS";
                        return false;
                    }
                    break;
                case op_code_1.OpCode.OP_IF:
                case op_code_1.OpCode.OP_NOTIF:
                    {
                        // <expression> if [statements] [else [statements]] endif
                        // bool fValue = false
                        let fValue = false;
                        if (fExec) {
                            const buf = this.stack.pop();
                            if (!buf) {
                                this.errStr = "SCRIPT_ERR_UNBALANCED_CONDITIONAL";
                                return false;
                            }
                            fValue = Interp.castToBool(buf);
                            if (opCodeNum === op_code_1.OpCode.OP_NOTIF) {
                                fValue = !fValue;
                            }
                        }
                        this.ifStack.push(fValue);
                    }
                    break;
                case op_code_1.OpCode.OP_ELSE:
                    if (this.ifStack.length === 0) {
                        this.errStr = "SCRIPT_ERR_UNBALANCED_CONDITIONAL";
                        return false;
                    }
                    this.ifStack[this.ifStack.length - 1] =
                        !this.ifStack[this.ifStack.length - 1];
                    break;
                case op_code_1.OpCode.OP_ENDIF:
                    if (this.ifStack.length === 0) {
                        this.errStr = "SCRIPT_ERR_UNBALANCED_CONDITIONAL";
                        return false;
                    }
                    this.ifStack.pop();
                    break;
                case op_code_1.OpCode.OP_VERIFY:
                    {
                        // (true -- ) or
                        // (false -- false) and return
                        if (this.stack.length < 1) {
                            this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                            return false;
                        }
                        const buf = this.stack[this.stack.length - 1];
                        const fValue = Interp.castToBool(buf);
                        if (fValue) {
                            this.stack.pop();
                        }
                        else {
                            this.errStr = "SCRIPT_ERR_VERIFY";
                            return false;
                        }
                    }
                    break;
                case op_code_1.OpCode.OP_RETURN: {
                    // If we're in the unlocking script context
                    if (this.context === "UnlockingScript") {
                        // Must have at least one stack item
                        if (this.stack.length < 1) {
                            this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                            return false;
                        }
                        // Check top stack value
                        const topValue = Interp.castToBool(this.stack[this.stack.length - 1]);
                        if (!topValue) {
                            this.errStr = "SCRIPT_ERR_OP_RETURN";
                            return false;
                        }
                        // If truthy, clear ifStack and skip to end of unlocking script
                        this.ifStack = []; // Clear ifStack before transitioning
                        // If truthy, skip to end of unlocking script
                        this.pc = this.scriptSig.chunks.length;
                        return true;
                    }
                    // If we're in the locking script context
                    if (this.context === "LockingScript") {
                        // Must have at least one stack item
                        if (this.stack.length < 1) {
                            this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                            return false;
                        }
                        // Verify top stack value is true (acts like OP_VERIFY)
                        const topValue = Interp.castToBool(this.stack[this.stack.length - 1]);
                        if (!topValue) {
                            this.errStr = "SCRIPT_ERR_OP_RETURN";
                            return false;
                        }
                        // If truthy, clear ifStack and skip to end of unlocking script
                        this.ifStack = []; // Clear ifStack before transitioning
                        // Skip to end of script
                        this.pc = this.scriptPubKey.chunks.length;
                        return true;
                    }
                    // Should never get here
                    this.errStr = "SCRIPT_ERR_OP_RETURN";
                    return false;
                }
                // unreachable code: break
                //
                // Stack ops
                //
                case op_code_1.OpCode.OP_TOALTSTACK:
                    const item = this.stack.pop();
                    if (!item) {
                        this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                        return false;
                    }
                    this.altStack.push(item);
                    break;
                case op_code_1.OpCode.OP_FROMALTSTACK:
                    const itemFrom = this.altStack.pop();
                    if (!itemFrom) {
                        this.errStr = "SCRIPT_ERR_INVALID_ALTSTACK_OPERATION";
                        return false;
                    }
                    this.stack.push(itemFrom);
                    break;
                case op_code_1.OpCode.OP_2DROP:
                    // (x1 x2 -- )
                    if (this.stack.length < 2) {
                        this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                        return false;
                    }
                    this.stack.pop();
                    this.stack.pop();
                    break;
                case op_code_1.OpCode.OP_2DUP:
                    {
                        // (x1 x2 -- x1 x2 x1 x2)
                        if (this.stack.length < 2) {
                            this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                            return false;
                        }
                        const buf1 = this.stack[this.stack.length - 2];
                        const buf2 = this.stack[this.stack.length - 1];
                        this.stack.push(buf1);
                        this.stack.push(buf2);
                    }
                    break;
                case op_code_1.OpCode.OP_3DUP:
                    {
                        // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)
                        if (this.stack.length < 3) {
                            this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                            return false;
                        }
                        const buf1 = this.stack[this.stack.length - 3];
                        const buf2 = this.stack[this.stack.length - 2];
                        const buf3 = this.stack[this.stack.length - 1];
                        this.stack.push(buf1);
                        this.stack.push(buf2);
                        this.stack.push(buf3);
                    }
                    break;
                case op_code_1.OpCode.OP_2OVER:
                    {
                        // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)
                        if (this.stack.length < 4) {
                            this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                            return false;
                        }
                        const buf1 = this.stack[this.stack.length - 4];
                        const buf2 = this.stack[this.stack.length - 3];
                        this.stack.push(buf1);
                        this.stack.push(buf2);
                    }
                    break;
                case op_code_1.OpCode.OP_2ROT:
                    {
                        // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)
                        if (this.stack.length < 6) {
                            this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                            return false;
                        }
                        const spliced = this.stack.splice(this.stack.length - 6, 2);
                        this.stack.push(spliced[0]);
                        this.stack.push(spliced[1]);
                    }
                    break;
                case op_code_1.OpCode.OP_2SWAP:
                    {
                        // (x1 x2 x3 x4 -- x3 x4 x1 x2)
                        if (this.stack.length < 4) {
                            this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                            return false;
                        }
                        const spliced = this.stack.splice(this.stack.length - 4, 2);
                        this.stack.push(spliced[0]);
                        this.stack.push(spliced[1]);
                    }
                    break;
                case op_code_1.OpCode.OP_IFDUP:
                    {
                        // (x - 0 | x x)
                        if (this.stack.length < 1) {
                            this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                            return false;
                        }
                        const buf = this.stack[this.stack.length - 1];
                        const fValue = Interp.castToBool(buf);
                        if (fValue) {
                            this.stack.push(buf);
                        }
                    }
                    break;
                case op_code_1.OpCode.OP_DEPTH:
                    {
                        // -- stacksize
                        const buf = new bn_1.Bn(this.stack.length).toScriptNumBuffer();
                        this.stack.push(buf);
                    }
                    break;
                case op_code_1.OpCode.OP_DROP:
                    // (x -- )
                    if (this.stack.length < 1) {
                        this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                        return false;
                    }
                    this.stack.pop();
                    break;
                case op_code_1.OpCode.OP_DUP:
                    // (x -- x x)
                    if (this.stack.length < 1) {
                        this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                        return false;
                    }
                    this.stack.push(this.stack[this.stack.length - 1]);
                    break;
                case op_code_1.OpCode.OP_NIP:
                    // (x1 x2 -- x2)
                    if (this.stack.length < 2) {
                        this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                        return false;
                    }
                    this.stack.splice(this.stack.length - 2, 1);
                    break;
                case op_code_1.OpCode.OP_OVER:
                    // (x1 x2 -- x1 x2 x1)
                    if (this.stack.length < 2) {
                        this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                        return false;
                    }
                    this.stack.push(this.stack[this.stack.length - 2]);
                    break;
                case op_code_1.OpCode.OP_PICK:
                case op_code_1.OpCode.OP_ROLL:
                    {
                        // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)
                        // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)
                        if (this.stack.length < 2) {
                            this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                            return false;
                        }
                        let buf = this.stack[this.stack.length - 1];
                        const bn = new bn_1.Bn().fromScriptNumBuffer(buf, fRequireMinimal);
                        const n = bn.toNumber();
                        this.stack.pop();
                        if (n < 0 || n >= this.stack.length) {
                            this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                            return false;
                        }
                        buf = this.stack[this.stack.length - n - 1];
                        if (opCodeNum === op_code_1.OpCode.OP_ROLL) {
                            this.stack.splice(this.stack.length - n - 1, 1);
                        }
                        this.stack.push(buf);
                    }
                    break;
                case op_code_1.OpCode.OP_ROT:
                    {
                        // (x1 x2 x3 -- x2 x3 x1)
                        //  x2 x1 x3  after first swap
                        //  x2 x3 x1  after second swap
                        if (this.stack.length < 3) {
                            this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                            return false;
                        }
                        const x1 = this.stack[this.stack.length - 3];
                        const x2 = this.stack[this.stack.length - 2];
                        const x3 = this.stack[this.stack.length - 1];
                        this.stack[this.stack.length - 3] = x2;
                        this.stack[this.stack.length - 2] = x3;
                        this.stack[this.stack.length - 1] = x1;
                    }
                    break;
                case op_code_1.OpCode.OP_SWAP:
                    {
                        // (x1 x2 -- x2 x1)
                        if (this.stack.length < 2) {
                            this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                            return false;
                        }
                        const x1 = this.stack[this.stack.length - 2];
                        const x2 = this.stack[this.stack.length - 1];
                        this.stack[this.stack.length - 2] = x2;
                        this.stack[this.stack.length - 1] = x1;
                    }
                    break;
                case op_code_1.OpCode.OP_TUCK:
                    // (x1 x2 -- x2 x1 x2)
                    if (this.stack.length < 2) {
                        this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                        return false;
                    }
                    this.stack.splice(this.stack.length - 2, 0, this.stack[this.stack.length - 1]);
                    break;
                case op_code_1.OpCode.OP_SIZE:
                    {
                        // (in -- in size)
                        if (this.stack.length < 1) {
                            this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                            return false;
                        }
                        const bn = new bn_1.Bn(this.stack[this.stack.length - 1].length);
                        this.stack.push(bn.toScriptNumBuffer());
                    }
                    break;
                //
                // Bitwise logic
                //
                case op_code_1.OpCode.OP_OR:
                case op_code_1.OpCode.OP_AND:
                case op_code_1.OpCode.OP_XOR:
                    // (x1 x2 -- out)
                    if (this.stack.length < 2) {
                        this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                        return false;
                    }
                    const buf1 = this.stack[this.stack.length - 2];
                    const buf2 = this.stack[this.stack.length - 1];
                    if (buf1.length !== buf2.length) {
                        this.errStr = "SCRIPT_ERR_INVALID_OPERAND_SIZE";
                        return false;
                    }
                    switch (opCodeNum) {
                        case op_code_1.OpCode.OP_AND:
                            for (let i = 0; i < buf1.length; i++) {
                                buf1[i] &= buf2[i];
                            }
                            break;
                        case op_code_1.OpCode.OP_OR:
                            for (let i = 0; i < buf1.length; i++) {
                                buf1[i] |= buf2[i];
                            }
                            break;
                        case op_code_1.OpCode.OP_XOR:
                            for (let i = 0; i < buf1.length; i++) {
                                buf1[i] ^= buf2[i];
                            }
                            break;
                    }
                    // pop out buf2
                    this.stack.pop();
                    break;
                case op_code_1.OpCode.OP_INVERT:
                    // (x -- out)
                    if (this.stack.length < 1) {
                        this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                        return false;
                    }
                    const buf = this.stack[this.stack.length - 1];
                    for (let i = 0; i < buf.length; i++) {
                        buf[i] = ~buf[i];
                    }
                    break;
                case op_code_1.OpCode.OP_LSHIFT:
                case op_code_1.OpCode.OP_RSHIFT: {
                    // (x n -- out)
                    if (this.stack.length < 2) {
                        this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                        return false;
                    }
                    const buf1 = this.stack[this.stack.length - 2];
                    let value = new bn_1.Bn(buf1);
                    const n = new bn_1.Bn()
                        .fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal)
                        .toNumber();
                    if (n < 0) {
                        this.errStr = "SCRIPT_ERR_INVALID_NUMBER_RANGE";
                        return false;
                    }
                    this.stack.pop();
                    this.stack.pop();
                    switch (opCodeNum) {
                        case op_code_1.OpCode.OP_LSHIFT:
                            value = value.ushln(n);
                            break;
                        case op_code_1.OpCode.OP_RSHIFT:
                            value = value.ushrn(n);
                            break;
                    }
                    let buf2 = value.toBuffer().slice(-buf1.length);
                    if (buf2.length < buf1.length) {
                        buf2 = Buffer.concat([
                            Buffer.alloc(buf1.length - buf2.length),
                            buf2,
                        ]);
                    }
                    this.stack.push(buf2);
                    break;
                }
                case op_code_1.OpCode.OP_EQUAL:
                case op_code_1.OpCode.OP_EQUALVERIFY:
                    // case OpCode.OP_NOTEQUAL: // use OpCode.OP_NUMNOTEQUAL
                    {
                        // (x1 x2 - bool)
                        if (this.stack.length < 2) {
                            this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                            return false;
                        }
                        const buf1 = this.stack[this.stack.length - 2];
                        const buf2 = this.stack[this.stack.length - 1];
                        const fEqual = (0, cmp_1.cmp)(buf1, buf2);
                        // OpCode.OP_NOTEQUAL is disabled because it would be too easy to say
                        // something like n != 1 and have some wiseguy pass in 1 with extra
                        // zero bytes after it (numerically, 0x01 == 0x0001 == 0x000001)
                        // if (opCode == OpCode.OP_NOTEQUAL)
                        //  fEqual = !fEqual
                        this.stack.pop();
                        this.stack.pop();
                        this.stack.push(fEqual ? Interp.true : Interp.false);
                        if (opCodeNum === op_code_1.OpCode.OP_EQUALVERIFY) {
                            if (fEqual) {
                                this.stack.pop();
                            }
                            else {
                                this.errStr = "SCRIPT_ERR_EQUALVERIFY";
                                return false;
                            }
                        }
                    }
                    break;
                //
                // Numeric
                //
                case op_code_1.OpCode.OP_1ADD:
                case op_code_1.OpCode.OP_1SUB:
                case op_code_1.OpCode.OP_NEGATE:
                case op_code_1.OpCode.OP_ABS:
                case op_code_1.OpCode.OP_NOT:
                case op_code_1.OpCode.OP_0NOTEQUAL:
                    {
                        // (in -- out)
                        if (this.stack.length < 1) {
                            this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                            return false;
                        }
                        const buf = this.stack[this.stack.length - 1];
                        let bn = new bn_1.Bn().fromScriptNumBuffer(buf, fRequireMinimal);
                        switch (opCodeNum) {
                            case op_code_1.OpCode.OP_1ADD:
                                bn = bn.add(1);
                                break;
                            case op_code_1.OpCode.OP_1SUB:
                                bn = bn.sub(1);
                                break;
                            case op_code_1.OpCode.OP_NEGATE:
                                bn = bn.neg();
                                break;
                            case op_code_1.OpCode.OP_ABS:
                                if (bn.lt(0)) {
                                    bn = bn.neg();
                                }
                                break;
                            case op_code_1.OpCode.OP_NOT:
                                bn = new bn_1.Bn(~~bn.eq(0));
                                break;
                            case op_code_1.OpCode.OP_0NOTEQUAL:
                                bn = new bn_1.Bn(~~bn.neq(0));
                                break;
                            // default:      assert(!"invalid opCode"); break; // TODO: does this ever occur?
                        }
                        this.stack.pop();
                        this.stack.push(bn.toScriptNumBuffer());
                    }
                    break;
                case op_code_1.OpCode.OP_ADD:
                case op_code_1.OpCode.OP_SUB:
                case op_code_1.OpCode.OP_MUL:
                case op_code_1.OpCode.OP_DIV:
                case op_code_1.OpCode.OP_MOD:
                case op_code_1.OpCode.OP_BOOLAND:
                case op_code_1.OpCode.OP_BOOLOR:
                case op_code_1.OpCode.OP_NUMEQUAL:
                case op_code_1.OpCode.OP_NUMEQUALVERIFY:
                case op_code_1.OpCode.OP_NUMNOTEQUAL:
                case op_code_1.OpCode.OP_LESSTHAN:
                case op_code_1.OpCode.OP_GREATERTHAN:
                case op_code_1.OpCode.OP_LESSTHANOREQUAL:
                case op_code_1.OpCode.OP_GREATERTHANOREQUAL:
                case op_code_1.OpCode.OP_MIN:
                case op_code_1.OpCode.OP_MAX:
                    {
                        // (x1 x2 -- out)
                        if (this.stack.length < 2) {
                            this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                            return false;
                        }
                        const bn1 = new bn_1.Bn().fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);
                        const bn2 = new bn_1.Bn().fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);
                        let bn = new bn_1.Bn(0);
                        switch (opCodeNum) {
                            case op_code_1.OpCode.OP_ADD:
                                bn = bn1.add(bn2);
                                break;
                            case op_code_1.OpCode.OP_SUB:
                                bn = bn1.sub(bn2);
                                break;
                            case op_code_1.OpCode.OP_MUL:
                                bn = bn1.mul(bn2);
                                break;
                            case op_code_1.OpCode.OP_DIV:
                                if (bn2.eq(0)) {
                                    this.errStr = "SCRIPT_ERR_DIV_BY_ZERO";
                                    return false;
                                }
                                bn = bn1.div(bn2);
                                break;
                            case op_code_1.OpCode.OP_MOD:
                                if (bn2.eq(0)) {
                                    this.errStr = "SCRIPT_ERR_DIV_BY_ZERO";
                                    return false;
                                }
                                bn = bn1.mod(bn2);
                                break;
                            // case OpCode.OP_BOOLAND:       bn = (bn1 != bnZero && bn2 != bnZero); break
                            case op_code_1.OpCode.OP_BOOLAND:
                                bn = new bn_1.Bn(~~(bn1.neq(0) && bn2.neq(0)));
                                break;
                            // case OpCode.OP_BOOLOR:        bn = (bn1 != bnZero || bn2 != bnZero); break
                            case op_code_1.OpCode.OP_BOOLOR:
                                bn = new bn_1.Bn(~~(bn1.neq(0) || bn2.neq(0)));
                                break;
                            // case OpCode.OP_NUMEQUAL:      bn = (bn1 == bn2); break
                            case op_code_1.OpCode.OP_NUMEQUAL:
                                bn = new bn_1.Bn(~~bn1.eq(bn2));
                                break;
                            // case OpCode.OP_NUMEQUALVERIFY:    bn = (bn1 == bn2); break
                            case op_code_1.OpCode.OP_NUMEQUALVERIFY:
                                bn = new bn_1.Bn(~~bn1.eq(bn2));
                                break;
                            // case OpCode.OP_NUMNOTEQUAL:     bn = (bn1 != bn2); break
                            case op_code_1.OpCode.OP_NUMNOTEQUAL:
                                bn = new bn_1.Bn(~~bn1.neq(bn2));
                                break;
                            // case OpCode.OP_LESSTHAN:      bn = (bn1 < bn2); break
                            case op_code_1.OpCode.OP_LESSTHAN:
                                bn = new bn_1.Bn(~~bn1.lt(bn2));
                                break;
                            // case OpCode.OP_GREATERTHAN:     bn = (bn1 > bn2); break
                            case op_code_1.OpCode.OP_GREATERTHAN:
                                bn = new bn_1.Bn(~~bn1.gt(bn2));
                                break;
                            // case OpCode.OP_LESSTHANOREQUAL:   bn = (bn1 <= bn2); break
                            case op_code_1.OpCode.OP_LESSTHANOREQUAL:
                                bn = new bn_1.Bn(~~bn1.leq(bn2));
                                break;
                            // case OpCode.OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break
                            case op_code_1.OpCode.OP_GREATERTHANOREQUAL:
                                bn = new bn_1.Bn(~~bn1.geq(bn2));
                                break;
                            case op_code_1.OpCode.OP_MIN:
                                bn = bn1.lt(bn2) ? bn1 : bn2;
                                break;
                            case op_code_1.OpCode.OP_MAX:
                                bn = bn1.gt(bn2) ? bn1 : bn2;
                                break;
                            // default:           assert(!"invalid opCode"); break; //TODO: does this ever occur?
                        }
                        this.stack.pop();
                        this.stack.pop();
                        this.stack.push(bn.toScriptNumBuffer());
                        if (opCodeNum === op_code_1.OpCode.OP_NUMEQUALVERIFY) {
                            // if (CastToBool(stacktop(-1)))
                            if (Interp.castToBool(this.stack[this.stack.length - 1])) {
                                this.stack.pop();
                            }
                            else {
                                this.errStr = "SCRIPT_ERR_NUMEQUALVERIFY";
                                return false;
                            }
                        }
                    }
                    break;
                case op_code_1.OpCode.OP_WITHIN:
                    {
                        // (x min max -- out)
                        if (this.stack.length < 3) {
                            this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                            return false;
                        }
                        const bn1 = new bn_1.Bn().fromScriptNumBuffer(this.stack[this.stack.length - 3], fRequireMinimal);
                        const bn2 = new bn_1.Bn().fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);
                        const bn3 = new bn_1.Bn().fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);
                        // bool fValue = (bn2 <= bn1 && bn1 < bn3)
                        const fValue = bn2.leq(bn1) && bn1.lt(bn3);
                        this.stack.pop();
                        this.stack.pop();
                        this.stack.pop();
                        this.stack.push(fValue ? Interp.true : Interp.false);
                    }
                    break;
                //
                // Crypto
                //
                case op_code_1.OpCode.OP_RIPEMD160:
                case op_code_1.OpCode.OP_SHA1:
                case op_code_1.OpCode.OP_SHA256:
                case op_code_1.OpCode.OP_HASH160:
                case op_code_1.OpCode.OP_HASH256:
                    {
                        // (in -- hash)
                        if (this.stack.length < 1) {
                            this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                            return false;
                        }
                        const buf = this.stack[this.stack.length - 1];
                        // valtype vchnew Hash((opCode == OpCode.OP_RIPEMD160 || opCode == OpCode.OP_SHA1 || opCode == OpCode.OP_HASH160) ? 20 : 32)
                        let bufHash = Buffer.from("");
                        if (opCodeNum === op_code_1.OpCode.OP_RIPEMD160) {
                            bufHash = hash_1.Hash.ripemd160(buf);
                        }
                        else if (opCodeNum === op_code_1.OpCode.OP_SHA1) {
                            bufHash = hash_1.Hash.sha1(buf);
                        }
                        else if (opCodeNum === op_code_1.OpCode.OP_SHA256) {
                            bufHash = hash_1.Hash.sha256(buf);
                        }
                        else if (opCodeNum === op_code_1.OpCode.OP_HASH160) {
                            bufHash = hash_1.Hash.sha256Ripemd160(buf);
                        }
                        else if (opCodeNum === op_code_1.OpCode.OP_HASH256) {
                            bufHash = hash_1.Hash.sha256Sha256(buf);
                        }
                        this.stack.pop();
                        this.stack.push(bufHash);
                    }
                    break;
                case op_code_1.OpCode.OP_CODESEPARATOR:
                    // Hash starts after the code separator
                    this.pBeginCodeHash = this.pc;
                    break;
                case op_code_1.OpCode.OP_CHECKSIG:
                case op_code_1.OpCode.OP_CHECKSIGVERIFY:
                    {
                        // (sig pubKey -- bool)
                        if (this.stack.length < 2) {
                            this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                            return false;
                        }
                        const bufSig = this.stack[this.stack.length - 2];
                        const bufPubKey = this.stack[this.stack.length - 1];
                        // Subset of script starting at the most recent codeseparator
                        // CScript scriptCode(pBeginCodeHash, pend)
                        const subScript = new script_1.Script().fromObject({
                            chunks: (_a = this.scriptPubKey.chunks) === null || _a === void 0 ? void 0 : _a.slice(this.pBeginCodeHash),
                        });
                        // https://github.com/Bitcoin-UAHF/spec/blob/master/replay-protected-sighash.md
                        const nHashType = bufSig.length > 0 ? bufSig.readUInt8(bufSig.length - 1) : 0;
                        if (nHashType & sig_1.Sig.SIGHASH_FORKID) {
                            if (!(this.flags & Interp.SCRIPT_ENABLE_SIGHASH_FORKID)) {
                                this.errStr = "SCRIPT_ERR_ILLEGAL_FORKID";
                                return false;
                            }
                        }
                        else {
                            subScript.findAndDelete(new script_1.Script().writeBuffer(bufSig));
                        }
                        const sigEncRes = this.checkSigEncoding(bufSig);
                        const pubKeyEncRes = this.checkPubKeyEncoding(bufPubKey);
                        if (!sigEncRes || !pubKeyEncRes) {
                            // serror is set
                            return false;
                        }
                        let fSuccess;
                        try {
                            const sig = new sig_1.Sig().fromTxFormat(bufSig);
                            const pubKey = new pub_key_1.PubKey().fromBuffer(bufPubKey, false);
                            const enforceLowS = false; // Boolean(this.flags & Interp.SCRIPT_VERIFY_LOW_S)
                            // console.log({
                            //     nIn: this.nIn,
                            //     subScript,
                            //     enforceLowS,
                            //     valueBn: this.valueBn,
                            //     flags: this.flags
                            // })
                            fSuccess = this.tx.verify(sig, pubKey, this.nIn, subScript, enforceLowS, this.valueBn, this.flags);
                            // console.warn({ fSuccess })
                        }
                        catch (e) {
                            // console.error({ e })
                            // invalid sig or pubKey
                            fSuccess = false;
                        }
                        this.stack.pop();
                        this.stack.pop();
                        // stack.push_back(fSuccess ? vchTrue : vchFalse)
                        this.stack.push(fSuccess ? Interp.true : Interp.false);
                        if (opCodeNum === op_code_1.OpCode.OP_CHECKSIGVERIFY) {
                            // console.log({ fSuccess })
                            if (fSuccess) {
                                this.stack.pop();
                            }
                            else {
                                this.errStr = "SCRIPT_ERR_CHECKSIGVERIFY";
                                return false;
                            }
                        }
                    }
                    break;
                case op_code_1.OpCode.OP_CHECKMULTISIG:
                case op_code_1.OpCode.OP_CHECKMULTISIGVERIFY:
                    {
                        // ([sig ...] num_of_signatures [pubKey ...] num_of_pubKeys -- bool)
                        let i = 1;
                        if (this.stack.length < i) {
                            this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                            return false;
                        }
                        let nKeysCount = new bn_1.Bn()
                            .fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal)
                            .toNumber();
                        if (nKeysCount < 0 || nKeysCount > 20) {
                            this.errStr = "SCRIPT_ERR_PUBKEY_COUNT";
                            return false;
                        }
                        this.nOpCount += nKeysCount;
                        if (this.nOpCount > 201) {
                            this.errStr = "SCRIPT_ERR_OP_COUNT";
                            return false;
                        }
                        // int ikey = ++i
                        let ikey = ++i;
                        i += nKeysCount;
                        if (this.stack.length < i) {
                            this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                            return false;
                        }
                        let nSigsCount = new bn_1.Bn()
                            .fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal)
                            .toNumber();
                        if (nSigsCount < 0 || nSigsCount > nKeysCount) {
                            this.errStr = "SCRIPT_ERR_SIG_COUNT";
                            return false;
                        }
                        // int isig = ++i
                        let isig = ++i;
                        i += nSigsCount;
                        if (this.stack.length < i) {
                            this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                            return false;
                        }
                        // Subset of script starting at the most recent codeseparator
                        const subScript = new script_1.Script().fromObject({
                            chunks: (_b = this.scriptPubKey.chunks) === null || _b === void 0 ? void 0 : _b.slice(this.pBeginCodeHash),
                        });
                        for (let k = 0; k < nSigsCount; k++) {
                            const bufSig = this.stack[this.stack.length - isig - k];
                            // https://github.com/Bitcoin-UAHF/spec/blob/master/replay-protected-sighash.md
                            const nHashType = bufSig.length > 0 ? bufSig.readUInt8(bufSig.length - 1) : 0;
                            if (nHashType & sig_1.Sig.SIGHASH_FORKID) {
                                if (!(this.flags & Interp.SCRIPT_ENABLE_SIGHASH_FORKID)) {
                                    this.errStr = "SCRIPT_ERR_ILLEGAL_FORKID";
                                    return false;
                                }
                            }
                            else {
                                // Drop the signature, since there's no way for a signature to sign itself
                                subScript.findAndDelete(new script_1.Script().writeBuffer(bufSig));
                            }
                        }
                        let fSuccess = true;
                        while (fSuccess && nSigsCount > 0) {
                            // valtype& vchSig  = stacktop(-isig)
                            const bufSig = this.stack[this.stack.length - isig];
                            // valtype& vchPubKey = stacktop(-ikey)
                            const bufPubKey = this.stack[this.stack.length - ikey];
                            if (!this.checkSigEncoding(bufSig) ||
                                !this.checkPubKeyEncoding(bufPubKey)) {
                                // serror is set
                                return false;
                            }
                            let fOk;
                            try {
                                const sig = new sig_1.Sig().fromTxFormat(bufSig);
                                const pubKey = new pub_key_1.PubKey().fromBuffer(bufPubKey, false);
                                fOk = this.tx.verify(sig, pubKey, this.nIn, subScript, false, 
                                //Boolean(this.flags & Interp.SCRIPT_VERIFY_LOW_S),
                                this.valueBn, this.flags);
                            }
                            catch (e) {
                                // invalid sig or pubKey
                                fOk = false;
                            }
                            if (fOk) {
                                isig++;
                                nSigsCount--;
                            }
                            ikey++;
                            nKeysCount--;
                            // If there are more signatures left than keys left,
                            // then too many signatures have failed
                            if (nSigsCount > nKeysCount) {
                                fSuccess = false;
                            }
                        }
                        // Clean up stack of actual arguments
                        while (i-- > 1) {
                            this.stack.pop();
                        }
                        // A bug causes CHECKMULTISIG to consume one extra argument
                        // whose contents were not checked in any way.
                        //
                        // Unfortunately this is a potential source of mutability,
                        // so optionally verify it is exactly equal to zero prior
                        // to removing it from the stack.
                        if (this.stack.length < 1) {
                            this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                            return false;
                        }
                        if (this.flags & Interp.SCRIPT_VERIFY_NULLDUMMY &&
                            this.stack[this.stack.length - 1].length) {
                            this.errStr = "SCRIPT_ERR_SIG_NULLDUMMY";
                            return false;
                        }
                        this.stack.pop();
                        // stack.push_back(fSuccess ? vchTrue : vchFalse)
                        this.stack.push(fSuccess ? Interp.true : Interp.false);
                        if (opCodeNum === op_code_1.OpCode.OP_CHECKMULTISIGVERIFY) {
                            if (fSuccess) {
                                this.stack.pop();
                            }
                            else {
                                this.errStr = "SCRIPT_ERR_CHECKMULTISIGVERIFY";
                                return false;
                            }
                        }
                    }
                    break;
                //
                // Byte string operations
                //
                case op_code_1.OpCode.OP_CAT:
                    if (this.stack.length < 2) {
                        this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                        return false;
                    }
                    const vch1 = this.stack[this.stack.length - 2];
                    const vch2 = this.stack[this.stack.length - 1];
                    this.stack[this.stack.length - 2] = Buffer.concat([vch1, vch2]);
                    this.stack.pop();
                    break;
                case op_code_1.OpCode.OP_SPLIT:
                    if (this.stack.length < 2) {
                        this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                        return false;
                    }
                    const data = this.stack[this.stack.length - 2];
                    const position = new bn_1.Bn().fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);
                    if (position.lt(0) || position.gt(data.length)) {
                        this.errStr = "SCRIPT_ERR_INVALID_SPLIT_RANGE";
                        return false;
                    }
                    const n1 = data.slice(0, position.toNumber());
                    const n2 = data.slice(position.toNumber());
                    this.stack.pop();
                    this.stack.pop();
                    this.stack.push(n1);
                    this.stack.push(n2);
                    break;
                //
                // Conversion operations
                //
                case op_code_1.OpCode.OP_NUM2BIN:
                    // (in -- out)
                    if (this.stack.length < 2) {
                        this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                        return false;
                    }
                    var size = new bn_1.Bn()
                        .fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal)
                        .toNumber();
                    // if (size > Interp.MAX_SCRIPT_ELEMENT_SIZE) {
                    //   this.errStr = 'SCRIPT_ERR_PUSH_SIZE'
                    //   return false
                    // }
                    this.stack.pop();
                    var rawnum = this.stack[this.stack.length - 1];
                    // Try to see if we can fit that number in the number of
                    // byte requested.
                    rawnum = Interp._minimallyEncode(rawnum);
                    if (rawnum.length > size) {
                        // We definitively cannot.
                        this.errStr = "SCRIPT_ERR_IMPOSSIBLE_ENCODING";
                        return false;
                    }
                    // We already have an element of the right size, we
                    // don't need to do anything.
                    if (rawnum.length === size) {
                        this.stack[this.stack.length - 1] = rawnum;
                        break;
                    }
                    var signbit = 0x00;
                    if (rawnum.length > 0) {
                        signbit = rawnum[rawnum.length - 1] & 0x80;
                        rawnum[rawnum.length - 1] &= 0x7f;
                    }
                    var num = Buffer.alloc(size);
                    rawnum.copy(num, 0);
                    var l = rawnum.length - 1;
                    while (l++ < size - 2) {
                        num[l] = 0x00;
                    }
                    num[l] = signbit;
                    this.stack[this.stack.length - 1] = num;
                    break;
                case op_code_1.OpCode.OP_BIN2NUM:
                    if (this.stack.length < 1) {
                        this.errStr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                        return false;
                    }
                    let buf1a = this.stack[this.stack.length - 1];
                    let buf2a = Interp._minimallyEncode(buf1a);
                    this.stack[this.stack.length - 1] = buf2a;
                    // The resulting number must be a valid number.
                    // if (!Interp._isMinimallyEncoded(buf2a)) {
                    //     this.errStr = 'SCRIPT_ERR_INVALID_NUMBER_RANGE'
                    //     return false
                    // }
                    break;
                default:
                    this.errStr = "SCRIPT_ERR_BAD_OPCODE";
                    return false;
            }
        }
        return true;
    }
    static _isMinimallyEncoded(buf) {
        const nMaxNumSize = Interp.MAXIMUM_ELEMENT_SIZE;
        if (buf.length > nMaxNumSize) {
            return false;
        }
        if (buf.length > 0) {
            // Check that the number is encoded with the minimum possible number
            // of bytes.
            //
            // If the most-significant-byte - excluding the sign bit - is zero
            // then we're not minimal. Note how this test also rejects the
            // negative-zero encoding, 0x80.
            if ((buf[buf.length - 1] & 0x7f) === 0) {
                // One exception: if there's more than one byte and the most
                // significant bit of the second-most-significant-byte is set it
                // would conflict with the sign bit. An example of this case is
                // +-255, which encode to 0xff00 and 0xff80 respectively.
                // (big-endian).
                if (buf.length <= 1 || (buf[buf.length - 2] & 0x80) === 0) {
                    return false;
                }
            }
        }
        return true;
    }
    static _minimallyEncode(buf) {
        if (buf.length === 0) {
            return buf;
        }
        // If the last byte is not 0x00 or 0x80, we are minimally encoded.
        var last = buf[buf.length - 1];
        if (last & 0x7f) {
            return buf;
        }
        // If the script is one byte long, then we have a zero, which encodes as an
        // empty array.
        if (buf.length === 1) {
            return Buffer.from("");
        }
        // If the next byte has it sign bit set, then we are minimaly encoded.
        if (buf[buf.length - 2] & 0x80) {
            return buf;
        }
        // We are not minimally encoded, we need to figure out how much to trim.
        for (var i = buf.length - 1; i > 0; i--) {
            // We found a non zero byte, time to encode.
            if (buf[i - 1] !== 0) {
                if (buf[i - 1] & 0x80) {
                    // We found a byte with it sign bit set so we need one more
                    // byte.
                    buf[i++] = last;
                }
                else {
                    // the sign bit is clear, we can use it.
                    buf[i - 1] |= last;
                }
                return buf.slice(0, i);
            }
        }
        // If we found the whole thing is zeros, then we have a zero.
        return Buffer.from("");
    }
    /**
     * This function has the same interface as bitcoin core's VerifyScript and is
     * the function you want to use to know if a particular input in a
     * transaction is valid or not. It simply iterates over the results generated
     * by the results method.
     */
    // Oh no:
    verify(scriptSig, scriptPubKey, tx, nIn, flags, valueBn) {
        const results = this.results(scriptSig, scriptPubKey, tx, nIn, flags, valueBn);
        for (const success of results) {
            if (!success) {
                return false;
            }
        }
        return true;
    }
    /**
     * Gives you the results of the execution each operation of the scripSig and
     * scriptPubKey corresponding to a particular input (nIn) for the concerned
     * transaction (tx). Each result can be either true or false. If true, then
     * the operation did not invalidate the transaction. If false, then the
     * operation has invalidated the script, and the transaction is not valid.
     * flags is a number that can pass in some special flags, such as whether or
     * not to execute the redeemScript in a p2sh transaction.
     *
     * This method is translated from bitcoin core's VerifyScript.  This function
     * is a generator, thus you can and need to iterate through it.  To
     * automatically return true or false, use the verify method.
     */
    *results(scriptSig, scriptPubKey, tx, nIn, flags, valueBn) {
        let stackCopy;
        this.fromObject({
            scriptSig,
            scriptPubKey,
            tx,
            nIn,
            flags,
            valueBn,
        });
        // if ((flags & Interp.SCRIPT_VERIFY_SIGPUSHONLY) !== 0 && !scriptSig.isPushOnly()) {
        //     this.errStr = this.errStr || 'SCRIPT_ERR_SIG_PUSHONLY'
        //     yield false
        // }
        yield* this.eval();
        // if (flags & Interp.SCRIPT_VERIFY_P2SH) {
        //     stackCopy = this.stack.slice()
        // }
        let stack = this.stack;
        // console.log("stack", stack);
        // this.initialize()
        // this.fromObject({
        //     script: scriptPubKey,
        //     stack,
        //     tx,
        //     nIn,
        //     flags,
        //     valueBn,
        // })
        // yield* this.eval()
        // console.log('stack', this.stack)
        if (this.stack.length === 0) {
            console.log(this.errStr);
            this.errStr = this.errStr || "SCRIPT_ERR_EVAL_FALSE";
            yield false;
        }
        const buf = this.stack[this.stack.length - 1];
        if (!Interp.castToBool(buf)) {
            this.errStr = this.errStr || "SCRIPT_ERR_EVAL_FALSE";
            yield false;
        }
        // Additional validation for spend-to-script-hash transactions:
        // if (flags & Interp.SCRIPT_VERIFY_P2SH && scriptPubKey.isScriptHashOut()) {
        //     // scriptSig must be literals-only or validation fails
        //     if (!scriptSig.isPushOnly()) {
        //         this.errStr = this.errStr || 'SCRIPT_ERR_SIG_PUSHONLY'
        //         yield false
        //     }
        //     // Restore stack.
        //     const tmp = stack
        //     stack = stackCopy
        //     stackCopy = tmp
        //     // stack cannot be empty here, because if it was the
        //     // P2SH  HASH <> EQUAL  scriptPubKey would be evaluated with
        //     // an empty stack and the EvalScript above would yield false.
        //     if (stack.length === 0) {
        //         throw new Error('internal error - stack copy empty')
        //     }
        //     const pubKeySerialized = stack[stack.length - 1]
        //     const scriptPubKey2 = new Script().fromBuffer(pubKeySerialized)
        //     stack.pop()
        //     this.initialize()
        //     this.fromObject({
        //         script: scriptPubKey2,
        //         stack,
        //         tx,
        //         nIn,
        //         flags,
        //         valueBn,
        //     })
        //     yield* this.eval()
        //     if (stack.length === 0) {
        //         this.errStr = this.errStr || 'SCRIPT_ERR_EVAL_FALSE'
        //         yield false
        //     }
        //     if (!Interp.castToBool(stack[stack.length - 1])) {
        //         this.errStr = this.errStr || 'SCRIPT_ERR_EVAL_FALSE'
        //         yield false
        //     } else {
        //         yield true
        //     }
        // }
        // The CLEANSTACK check is only performed after potential P2SH evaluation,
        // as the non-P2SH evaluation of a P2SH script will obviously not result in
        // // a clean stack (the P2SH inputs remain).
        // if ((flags & Interp.SCRIPT_VERIFY_CLEANSTACK) !== 0) {
        //     // Disallow CLEANSTACK without P2SH, as otherwise a switch
        //     // CLEANSTACK->P2SH+CLEANSTACK would be possible, which is not a softfork
        //     // (and P2SH should be one).
        //     if (!(flags & Interp.SCRIPT_VERIFY_P2SH)) {
        //         throw new Error('cannot use CLEANSTACK without P2SH')
        //     }
        // if (stack.length !== 1) {
        //     this.errStr = this.errStr || 'SCRIPT_ERR_CLEANSTACK' // Does not matter for SPV or TN
        //     yield false
        // }
        // }
        yield true;
    }
    /**
     * If the script has failed, this methods returns valuable debug
     * information about exactly where the script failed. It is a
     * JSON-compatible object so it can be easily stringified. pc refers to the
     * currently executing opcode.
     */
    getDebugObject() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        // const pc = this.pc - 2; // pc is incremented immediately after getting
        // console.log(this?.script?.chunks?.length, pc, this?.execSteps?.[pc])
        let opCodeStr = "no script found"; // Default message
        // console.warn('this?.script?.chunks?.[pc]?.opCodeNum', this?.script?.chunks?.[pc]?.opCodeNum)
        // if (this?.scriptPubKey?.chunks?.[pc]?.opCodeNum !== undefined) {
        //   const opCodeNum = this.scriptPubKey.chunks[pc]?.opCodeNum;
        //   const opCode = OpCode.fromNumber(opCodeNum);
        //   if (opCode) {
        //     opCodeStr = opCode.toString();
        //   }
        // }
        if (this.context === "UnlockingScript") {
            if (((_c = (_b = (_a = this === null || this === void 0 ? void 0 : this.scriptSig) === null || _a === void 0 ? void 0 : _a.chunks) === null || _b === void 0 ? void 0 : _b[this.pc - 1]) === null || _c === void 0 ? void 0 : _c.opCodeNum) !== undefined) {
                const opCodeNum = (_d = this.scriptSig.chunks[this.pc - 1]) === null || _d === void 0 ? void 0 : _d.opCodeNum;
                const opCode = op_code_1.OpCode.fromNumber(opCodeNum);
                if (opCode) {
                    opCodeStr = opCode.toString();
                }
            }
        }
        else {
            if (((_g = (_f = (_e = this === null || this === void 0 ? void 0 : this.scriptPubKey) === null || _e === void 0 ? void 0 : _e.chunks) === null || _f === void 0 ? void 0 : _f[this.pc - 1]) === null || _g === void 0 ? void 0 : _g.opCodeNum) !== undefined) {
                const opCodeNum = (_h = this.scriptPubKey.chunks[this.pc - 1]) === null || _h === void 0 ? void 0 : _h.opCodeNum;
                const opCode = op_code_1.OpCode.fromNumber(opCodeNum);
                if (opCode) {
                    opCodeStr = opCode.toString();
                }
            }
        }
        const interfaceScript = new script_1.Script().writeScript(this.scriptSig).writeScript(this.scriptPubKey);
        // interfaceScript.chunks.concat(...this.scriptSig.chunks)
        // interfaceScript.chunks.concat(...this.scriptPubKey.chunks)
        // console.log({interfaceScript})
        return {
            errStr: this.errStr,
            scriptSig: this.scriptSig,
            scriptPubKey: this.scriptPubKey,
            scriptStr: interfaceScript
                ? interfaceScript === null || interfaceScript === void 0 ? void 0 : interfaceScript.toString()
                : "no script found",
            pc: this.pc - 1,
            stack: (_j = this.stack) === null || _j === void 0 ? void 0 : _j.map((buf) => buf.toString("hex")),
            altStack: (_k = this.altStack) === null || _k === void 0 ? void 0 : _k.map((buf) => buf.toString("hex")),
            opCodeStr, //: this?.script?.chunks?.[pc]?.opCodeNum ? OpCode.fromNumber(this?.script?.chunks?.[pc]?.opCodeNum)?.toString() : 'no script found',
            execSteps: this.execSteps,
        };
    }
    getDebugString() {
        return JSON.stringify(this === null || this === void 0 ? void 0 : this.getDebugObject(), null, 2);
    }
}
exports.Interp = Interp;
Interp.true = Buffer.from([1]);
Interp.false = Buffer.from([]);
// public static readonly MAX_SCRIPT_ELEMENT_SIZE = 520
Interp.LOCKTIME_THRESHOLD = 500000000; // Tue Nov  5 00:53:20 1985 UTC
// flags taken from bitcoin core
// bitcoin core commit: b5d1b1092998bc95313856d535c632ea5a8f9104
Interp.SCRIPT_VERIFY_NONE = 0;
// Evaluate P2SH subScripts (softfork safe, Bip16).
// public static readonly SCRIPT_VERIFY_P2SH = 1 << 0
// Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.
// Passing a pubKey that is not (0x04 + 64 bytes) or (0x02 or 0x03 + 32 bytes) to checksig causes that pubKey to be
// skipped (not softfork safe: this flag can widen the validity of OP_CHECKSIG OP_NOT).
Interp.SCRIPT_VERIFY_STRICTENC = 1 << 1;
// Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, Bip62 rule 1)
Interp.SCRIPT_VERIFY_DERSIG = 1 << 2;
// Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script failure
// (softfork safe, Bip62 rule 5).
// public static readonly SCRIPT_VERIFY_LOW_S = 1 << 3
// verify dummy stack item consumed by CHECKMULTISIG is of zero-length (softfork safe, Bip62 rule 7).
Interp.SCRIPT_VERIFY_NULLDUMMY = 1 << 4;
// Using a non-push operator in the scriptSig causes script failure (softfork safe, Bip62 rule 2).
// public static readonly SCRIPT_VERIFY_SIGPUSHONLY = 1 << 5
// Require minimal encodings for all push operations (OP_0... OP_16, OP_1NEGATE where possible, direct
// pushes up to 75 bytes, OP_PUSHDATA up to 255 bytes, OP_PUSHDATA2 for anything larger). Evaluating
// any other push causes the script to fail (Bip62 rule 3).
// In addition, whenever a stack element is interpreted as a number, it must be of minimal length (Bip62 rule 4).
// (softfork safe)
// public static readonly SCRIPT_VERIFY_MINIMALDATA = 1 << 6
// Discourage use of NOPs reserved for upgrades (NOP1-10)
//
// Provided so that nodes can avoid accepting or mining transactions
// containing executed NOP's whose meaning may change after a soft-fork,
// thus rendering the script invalid; with this flag set executing
// discouraged NOPs fails the script. This verification flag will never be
// a mandatory flag applied to scripts in a block. NOPs that are not
// executed, e.g.  within an unexecuted IF ENDIF block, are *not* rejected.
Interp.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = 1 << 7;
// Require that only a single stack element remains after evaluation. This
// changes the success criterion from "At least one stack element must
// remain, and when interpreted as a boolean, it must be true" to "Exactly
// one stack element must remain, and when interpreted as a boolean, it must
// be true".  (softfork safe, Bip62 rule 6)
// Note: CLEANSTACK should never be used without P2SH.
// public static readonly SCRIPT_VERIFY_CLEANSTACK = 1 << 8
// Verify CHECKLOCKTIMEVERIFY
//
// See Bip65 for details.
Interp.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY = 1 << 9;
// support CHECKSEQUENCEVERIFY opCode
//
// See Bip112 for details
Interp.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY = 1 << 10;
// used for UAHF
// https://github.com/Bitcoin-UAHF/spec/blob/master/replay-protected-sighash.md
Interp.SCRIPT_ENABLE_SIGHASH_FORKID = 1 << 16;
// These are the things we wish to verify by default. At the time of writing,
// P2SH and CHECKLOCKTIMEVERIFY are both active, but CHECKSEQUENCEVERIFY is
// not.
Interp.defaultFlags = Interp.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY;
Interp.MAXIMUM_ELEMENT_SIZE = 10 * 1000; // ONE_KILOBYTE
//# sourceMappingURL=interp.js.map